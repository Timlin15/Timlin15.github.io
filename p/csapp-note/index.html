<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://Timlin15.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://Timlin15.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://Timlin15.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://Timlin15.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://Timlin15.github.io/css/light.css' />
    <link rel="stylesheet" href='https://Timlin15.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://Timlin15.github.io/css/syntax.css' />
    <title>CSAPP Note - 知言的博客</title>
    
    <link rel="icon" type="image/x-icon" href='/images/favion.ico'>
    
    <meta name="theme-color" content="#1e2327">

    
    

    
    <meta name="description"
  content="一个计算机系统基础的笔记" />
<meta name="keywords"
  content='' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://Timlin15.github.io/p/csapp-note/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="CSAPP Note - 知言的博客" />
<meta name="twitter:description"
  content="一个计算机系统基础的笔记" />
<meta name="twitter:site" content="https://Timlin15.github.io/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image"
  content="https://Timlin15.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="CSAPP Note - 知言的博客">
<meta property="og:description"
  content="一个计算机系统基础的笔记" />
<meta property="og:url" content="https://Timlin15.github.io/p/csapp-note/" />
<meta property="og:site_name" content="CSAPP Note" />
<meta property="og:image"
  content="https://Timlin15.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2025-04-07 22:51:30 &#43;0800 CST" />











</head>


<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://Timlin15.github.io/">
        <img class="octicon" height="32" width="32" src="/images/avatar.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          
          <form target="_blank" id="search-form" action="" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
            </label>
          </form>
          
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://Timlin15.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/avatar.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  <div id="search-result" class="container-lg px-3 new-discussion-timeline" style="display: none;">
</div>

  
<div class="application-main">
  <div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://Timlin15.github.io/">
                  <img class=" avatar-user"
                    src="/images/avatar.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://Timlin15.github.io/">知言</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://Timlin15.github.io/p/csapp-note/">CSAPP Note</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Mon, 07 Apr 2025 22:51:30 &#43;0800"
                    class="no-wrap">
                    Mon, 07 Apr 2025 22:51:30 &#43;0800</relative-time>

                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      31431 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="/tags/%E7%AC%94%E8%AE%B0">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      笔记
                    </a>
                    
                    <a class="muted-link mr-3" href="/tags/cs">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      CS
                    </a>
                    
                    <a class="muted-link mr-3" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机系统基础
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="note-of-computer-system-a-programmers-perspective">Note of Computer System: a Programmer&rsquo;s perspective.</h1>
<blockquote>
<p>[!NOTE]</p>
<p>这个笔记是由2015年CMU15-213课程内容slides和网上相关笔记总结而成，目的是在整合各路笔记中巩固自己的知识。主要是消化为主，所以个人产出较少，由于参考了多方资料会出现中英混杂情况。由于课程slide不好整合成md格式，而小土刀的笔记又正好是slide的汉化，所以会以其博客为基底补充。</p>
<p>CSapp是一门很广泛的计算机体系基础课，遍及数据底层表述，汇编代码，调用逻辑，内存结构，链接，异常流控制，并行，线程，虚拟内存和缓存的Index。本课程为程序员观察底层硬件实现提供了新的视角，很好的解释了C等语言中一些特性的原因。而诸如线程，进程等内容则为以后学习OS等课程打好了基础。</p>
<blockquote>
<p>主要资料：</p>
<ul>
<li>lecture: <a href="https://www.bilibili.com/video/BV1iW411d7hd">2015年课程视频</a>, <a href="https://learncs.me/cmu/15213">2017年课程视频</a></li>
<li>slide&amp;lab: <a href="https://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html">2015年官网</a></li>
<li>note: <a href="https://wdxtub.com/work/">小土刀笔记</a>，<a href="https://arthals.ink/blog/data-lab">lab笔记</a></li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p>Course theme: <strong>Abstraction Is Good But Don’t Forget Reality</strong></p>
<p>Great realities from the overview of CSAPP:</p>
<ol>
<li><strong>Ints</strong> <strong>are not Integers, Floats are not</strong> <strong>Reals</strong></li>
<li><strong>You’ve Got to Know Assembly</strong></li>
<li><strong>Memory Matters.</strong> <strong>Random Access Memory Is an Unphysical Abstraction</strong></li>
<li><strong>There’s more to performance than asymptotic</strong> <strong>complexity</strong>
<ul>
<li><strong>Constant factors matter too!</strong></li>
<li><strong>And even exact op count does not predict performance</strong>
<ul>
<li>Easily see 10:1 performance range depending on how code written</li>
<li>Must optimize at multiple levels: algorithm, data representations, procedures, and loops</li>
</ul>
</li>
<li><strong>Must understand system to optimize performance</strong></li>
</ul>
</li>
<li><strong>Computers do more than execute programs</strong></li>
</ol>
</blockquote>
<h2 id="1bits-bytes-and-integers">1.<strong>Bits, Bytes, and Integers</strong></h2>
<table>
  <thead>
      <tr>
          <th>C Data Type</th>
          <th>Typical 32-bit</th>
          <th>Typical 64-bit</th>
          <th>x86-64</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>char</td>
          <td>1</td>
          <td>1</td>
          <td>1</td>
      </tr>
      <tr>
          <td>short</td>
          <td>2</td>
          <td>2</td>
          <td>2</td>
      </tr>
      <tr>
          <td>int</td>
          <td>4</td>
          <td>4</td>
          <td>4</td>
      </tr>
      <tr>
          <td>long</td>
          <td>4</td>
          <td>8</td>
          <td>8</td>
      </tr>
      <tr>
          <td>float</td>
          <td>4</td>
          <td>4</td>
          <td>4</td>
      </tr>
      <tr>
          <td>double</td>
          <td>8</td>
          <td>8</td>
          <td>8</td>
      </tr>
      <tr>
          <td>long double</td>
          <td>-</td>
          <td>-</td>
          <td>10/16</td>
      </tr>
      <tr>
          <td>pointer</td>
          <td>4</td>
          <td>8</td>
          <td>8</td>
      </tr>
  </tbody>
</table>
<h3 id="boolean-algebra">Boolean Algebra</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">	01101001				01101001				01101001			
</span></span><span class="line"><span class="cl">&amp;   01010101			|	01010101			^	 01010101					~	01010101
</span></span><span class="line"><span class="cl">---------------			---------------			---------------					--------------
</span></span><span class="line"><span class="cl">	01000001				01111101				00111100					    10101010
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="shift-operations"><strong>Shift Operations</strong></h3>
<ul>
<li>
<p><strong>Left Shift:</strong>  <strong>x</strong> <strong>&laquo;</strong> <strong>y</strong></p>
<ul>
<li>
<p>Shift bit-vector <strong>x</strong> left <strong>y</strong> positions.</p>
<p>Throw away extra bits on left.</p>
<p>Fill with 0’s on right</p>
</li>
</ul>
</li>
<li>
<p><strong>Right Shift:</strong>  <strong>x</strong> <strong>&raquo;</strong> <strong>y</strong></p>
<ul>
<li>Logical shift
<ul>
<li>Fill with 0’s on left</li>
</ul>
</li>
<li>Arithmetic shift
<ul>
<li>Fill with the most significant bit on the left</li>
</ul>
</li>
</ul>
  <img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/20250224160408.png" style="zoom:33%;" />
</li>
</ul>
<h3 id="representation-unsigned-and-signed"><strong>Representation: unsigned and signed</strong></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">  x =      15213: 00111011 01101101
</span></span><span class="line"><span class="cl">  y =     -15213: 11000100 10010011
</span></span><span class="line"><span class="cl">  the most significant bit of int is -2^w
</span></span><span class="line"><span class="cl">  the negative number is represented in 2&#39;s complement way: y = ~x + 1.
</span></span></code></pre></td></tr></table>
</div>
</div><table>
  <thead>
      <tr>
          <th>\( X \)</th>
          <th>B2U(X)</th>
          <th>B2T(X)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0000</td>
          <td>0</td>
          <td>0</td>
      </tr>
      <tr>
          <td>0001</td>
          <td>1</td>
          <td>1</td>
      </tr>
      <tr>
          <td>0010</td>
          <td>2</td>
          <td>2</td>
      </tr>
      <tr>
          <td>0011</td>
          <td>3</td>
          <td>3</td>
      </tr>
      <tr>
          <td>0100</td>
          <td>4</td>
          <td>4</td>
      </tr>
      <tr>
          <td>0101</td>
          <td>5</td>
          <td>5</td>
      </tr>
      <tr>
          <td>0110</td>
          <td>6</td>
          <td>6</td>
      </tr>
      <tr>
          <td>0111</td>
          <td>7</td>
          <td>7</td>
      </tr>
      <tr>
          <td>1000</td>
          <td>8</td>
          <td>-8</td>
      </tr>
      <tr>
          <td>1001</td>
          <td>9</td>
          <td>-7</td>
      </tr>
      <tr>
          <td>1010</td>
          <td>10</td>
          <td>-6</td>
      </tr>
      <tr>
          <td>1011</td>
          <td>11</td>
          <td>-5</td>
      </tr>
      <tr>
          <td>1100</td>
          <td>12</td>
          <td>-4</td>
      </tr>
      <tr>
          <td>1101</td>
          <td>13</td>
          <td>-3</td>
      </tr>
      <tr>
          <td>1110</td>
          <td>14</td>
          <td>-2</td>
      </tr>
      <tr>
          <td>1111</td>
          <td>15</td>
          <td>-1</td>
      </tr>
  </tbody>
</table>
<ul>
<li>UMin = 0 即 000…0</li>
<li>UMax = $2^w−1$ 即 111…1</li>
<li>TMin = $−2^w−1$ 即 100…0</li>
<li>TMax = $2^{w-1}-1$ 即 011…1</li>
<li>Minus 1 即 111…1</li>
</ul>
<p>For different word size, there can be different outcome.</p>
<table>
  <thead>
      <tr>
          <th>w</th>
          <th>8</th>
          <th>16</th>
          <th>32</th>
          <th>64</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>UMax</td>
          <td>255</td>
          <td>65,535</td>
          <td>4,294,967,295</td>
          <td>18,446,744,073,709,551,615</td>
      </tr>
      <tr>
          <td>TMax</td>
          <td>127</td>
          <td>32,767</td>
          <td>2,147,483,647</td>
          <td>9,223,372,036,854,775,807</td>
      </tr>
      <tr>
          <td>TMin</td>
          <td>-128</td>
          <td>-32,768</td>
          <td>-2,147,483,648</td>
          <td>-9,223,372,036,854,775,808</td>
      </tr>
  </tbody>
</table>
<p>From above we can get 2 important property:</p>
<ol>
<li>|TMin| = TMax + 1 (范围并不是对称的)</li>
<li>UMax = $2\times TMax + 1$</li>
<li>Signed number and unsigned number have the same encoding for positive number.
<ul>
<li>$U2B(x)=B2U^{−1}(x)$</li>
<li>$T2B(x)=B2T^{−1}(x)$</li>
</ul>
</li>
</ol>
<h4 id="conversion-casting">Conversion, casting</h4>
<p>类型扩展与截取具体需要分情况讨论，如：</p>
<ul>
<li>扩展（例如从<code>short int</code>到<code>int</code>），都可以得到预期的结果
<ul>
<li>无符号数：加 0</li>
<li>有符号数：加符号位</li>
</ul>
</li>
<li>截取（例如<code>unsigned</code>到<code>unsigned short</code>），对于小的数字可以得到预期的结果
<ul>
<li>无符号数：mod 操作</li>
<li>有符号数：近似 mod 操作</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>decimal</th>
          <th>hex</th>
          <th>binary</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>x=15213</td>
          <td>3B 6D</td>
          <td>00111011 01101101</td>
      </tr>
      <tr>
          <td>bx=15213</td>
          <td>00 00 3B 6D</td>
          <td>00000000 00000000 00111011 01101101</td>
      </tr>
      <tr>
          <td>y=-15213</td>
          <td>C4 93</td>
          <td>11000100 10010011</td>
      </tr>
      <tr>
          <td>iy=-15213</td>
          <td>FF FF C4 93</td>
          <td>11111111 11111111 11000100 10010011</td>
      </tr>
  </tbody>
</table>
<div style="text-align: center;">
    <img scr = <img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250224161122909.png" alt="image-20250224161122909" style="zoom: 20%;" />
    <img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250224165149638.png" alt="image-20250224165149638" style="zoom: 50%;" />
    <img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250224171349437.png" alt="image-20250224171349437" style="zoom:30%;" />
</div>
<p>If sum $\geq$ $2^{w-1}$, the result becomes negative, and if sum $\leq , -2^{w-1}$, the result becomes positive, both at most once.</p>
<h4 id="shift">Shift</h4>
<p>Operation:</p>
<ul>
<li><strong>u &laquo; k</strong> gives $u \times 2^k$ for both signed and unsigned</li>
<li><strong>u &raquo; k</strong> gives ⌊ u / 2^k ⌋ by using logical shift for unsigned, arithmetic shift by signed.</li>
</ul>
<h3 id="byte-ordering-example"><strong>Byte Ordering Example</strong></h3>
<ul>
<li>Big Endian: The most significant byte is on the right. Used in IA32, x86</li>
<li>Little Endian: The most significant byte is on the left. Used in Sun.</li>
</ul>
<h2 id="2float">2.Float</h2>
<p>Float can be represented by a universal formula:</p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250225144248680.png" alt="image-20250225144248680" style="zoom:25%;" />
$$
∑_{k=−j}^ib_k×2^k
$$
For instance:
$$
5\,\frac34=101.11_2,\quad2\,\frac78=10.111_2,\quad1\frac7{16}=1.0111_2
$$
<h3 id="ieee-floating-point">IEEE floating point</h3>
<h4 id="normalized-value">Normalized value:</h4>
$$
v=(−1)^sM\times2^E
$$<p>The E here is exp with bias: $E = Exp - Bias$, where</p>
<ul>
<li>
<p>$Exp$: is the unsigned value encoded by $exp$.</p>
</li>
<li>
<p>$Bias$: with the value of $2^{k-1}-1$, where $k$ is the bits number of $exp$ encodes.</p>
<ul>
<li>$float$: 127(Exp: 1&hellip;254, E:-126&hellip;127)</li>
<li>$double$: 1023 (Exp:1&hellip;2046, E:-1022&hellip;1023)</li>
</ul>
<p>The $Exp$ is encoded this way to ensure it can be compared conveniently.</p>
</li>
<li>
<p>for normalized float, the M part only encode the decimal part following 1.</p>
</li>
</ul>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14609515849125.jpg" alt="img" style="zoom:50%;" />
$$
152131.0=11101101101101_2=1.1101101101101_2×2^{13}\\
Exp = E + Bias = 13 + 127 = 140 = 10001100_2
$$
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">0 10001100 11011011011010000000000
</span></span><span class="line"><span class="cl">s   exp             frac
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="denormalized-values"><strong>Denormalized Values</strong></h4>
<p>When the $exp$ is 0&hellip;000, the value is denormalized,</p>
<p><strong>Exponent value: E = 1 – Bias (instead of E = 0 – Bias)</strong> to make</p>
<p>Significant coded with implied leading 0: M = $0.xxx…x_2$</p>
<ul>
<li>xxx…x: bits of frac</li>
</ul>
<p>Cases</p>
<ul>
<li>
<p>exp = <strong>000…0</strong>, frac = <strong>000…0</strong></p>
<ul>
<li>
<p>Represents zero value</p>
</li>
<li>
<p>Note distinct values: +0 and –0</p>
<ul>
<li>because sign bit can denote positive/negative value</li>
</ul>
</li>
</ul>
</li>
<li>
<p>exp = <strong>000…0</strong>, frac ≠ <strong>000…0</strong></p>
<ul>
<li>Numbers closest to 0.0</li>
<li>Equispaced</li>
</ul>
</li>
</ul>
<h4 id="special-value">Special Value</h4>
<p>Condition: $exp$ = 111&hellip;1.</p>
<p>Case: $exp$ = 111&hellip;1, $frac$ = 000&hellip;0.</p>
<ul>
<li>Represent +$\infty$</li>
<li>Operation that overflows</li>
<li>Both positive and negative</li>
</ul>
<p>Case: $exp$ = 111&hellip;1, $frac \ne$ 000&hellip;0</p>
<ul>
<li>Not-a-number(NaN)</li>
<li>Represents case when no numeric value can be determined</li>
<li>E.g. $\sqrt{-1}, \infty-\infty,\infty \times 0$</li>
</ul>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250225145623205.png" alt="image-20250225145623205" style="zoom:33%;" />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">    s exp  frac   E   值
</span></span><span class="line"><span class="cl">------------------------------------------------------------------
</span></span><span class="line"><span class="cl">    0 0000 000   -6   0   # 这部分是非规范化数值，下一部分是规范化值
</span></span><span class="line"><span class="cl">    0 0000 001   -6   1/8 * 1/64 = 1/512 # 能表示的最接近零的值
</span></span><span class="line"><span class="cl">    0 0000 010   -6   2/8 * 1/64 = 2/512 
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    0 0000 110   -6   6/8 * 1/64 = 6/512
</span></span><span class="line"><span class="cl">    0 0000 111   -6   7/8 * 1/64 = 7/512 # 能表示的最大非规范化值
</span></span><span class="line"><span class="cl">------------------------------------------------------------------
</span></span><span class="line"><span class="cl">    0 0001 000   -6   8/8 * 1/64 = 8/512 # 能表示的最小规范化值
</span></span><span class="line"><span class="cl">    0 0001 001   -6   9/8 * 1/64 = 9/512
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    0 0110 110   -1   14/8 * 1/2 = 14/16
</span></span><span class="line"><span class="cl">    0 0110 111   -1   15/8 * 1/2 = 15/16 # 最接近且小于 1 的值
</span></span><span class="line"><span class="cl">    0 0111 000    0   8/8 * 1 = 1
</span></span><span class="line"><span class="cl">    0 0111 001    0   9/8 * 1 = 9/8      # 最接近且大于 1 的值
</span></span><span class="line"><span class="cl">    0 0111 010    0   10/8 * 1 = 10/8
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    0 1110 110    7   14/8 * 128 = 224
</span></span><span class="line"><span class="cl">    0 1110 111    7   15/8 * 128 = 240   # 能表示的最大规范化值
</span></span><span class="line"><span class="cl">------------------------------------------------------------------
</span></span><span class="line"><span class="cl">    0 1111 000   n/a  无穷               # 特殊值
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="rounding-addition-multiplication">Rounding, addition, multiplication</h4>
<p><strong>Rounding</strong></p>
<p>对于浮点数的加法和乘法来说，我们可以先计算出准确值，然后转换到合适的精度。在这个过程中，既可能会溢出，也可能需要舍入来满足 frac 的精度。</p>
<p>在二进制中，我们舍入到最近的偶数，即如果出现在中间的情况，舍入之后最右边的值要是偶数，对于十进制数，例子如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">  原数值       舍入结果    原因
</span></span><span class="line"><span class="cl">2.8949999      2.89    不到一半，正常四舍五入
</span></span><span class="line"><span class="cl">2.8950001      2.90    超过一般，正常四舍五入
</span></span><span class="line"><span class="cl">2.8950000      2.90    刚好在一半时，保证最后一位是偶数，所以向上舍入
</span></span><span class="line"><span class="cl">2.8850000      2.88    刚好在一半时，保证最后一位是偶数，所以向下舍入
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于二进制数也是类似的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">  十进制    二进制     舍入结果  十进制    原因
</span></span><span class="line"><span class="cl">2 又 3/32  10.00011   10.00     2      不到一半，正常四舍五入
</span></span><span class="line"><span class="cl">2 又 3/16  10.00110   10.01  2 又 1/4   超过一般，正常四舍五入
</span></span><span class="line"><span class="cl">2 又 7/8   10.11100   11.00     3      刚好在一半时，保证最后一位是偶数，所以向上舍入
</span></span><span class="line"><span class="cl">2 又 5/8   10.10100   10.10  2 又 1/2   刚好在一半时，保证最后一位是偶数，所以向下舍入
</span></span></code></pre></td></tr></table>
</div>
</div><p>舍入至最近的偶数是因为防止大量舍入都四舍五入导致数值整体偏大，向偶数舍入可平均舍入影响。</p>
$$
(–1)^{s1} M_1 2^{E1}   +   (-1)^{s2} M_2  2^{E2}
$$<ul>
<li>
<p>Exact Result: $(–1)^s M 2^E$</p>
<ul>
<li>
<p>Sign s, significand M:</p>
<ul>
<li>Result of signed align &amp; add</li>
</ul>
</li>
<li>
<p>Exponent E:  E1</p>
</li>
</ul>
</li>
</ul>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250225151309766.png" alt="image-20250225151309766" style="zoom:33%;" />
<ul>
<li>
<p>Fixing</p>
<ul>
<li>
<p>If M ≥ 2, shift M right, increment E</p>
</li>
<li>
<p>if M &lt; 1, shift M left k positions, decrement E by k</p>
</li>
<li>
<p>Overflow if E out of range</p>
</li>
<li>
<p>Round M to fit frac precision</p>
</li>
</ul>
</li>
</ul>
<p>基本性质</p>
<ul>
<li>相加可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失，如 <code>(3.14+1e10)-1e10=0</code>，但 <code>3.14+(1e10-1e10)=3.14</code>）</li>
<li>加上 0 等于原来的数</li>
<li>除了 infinity 和 NaN，每个元素都有对应的倒数</li>
<li>除了 infinity 和 NaN，满足单调性，即 a≥b→a+c≥b+c</li>
</ul>
$$
(−1)^{s1}M_12^{E1}×(−1)^{s2}M_22^{E2}
$$<p>
结果是 $(−1)^sM^{2E}$，其中 $s=s_1∧s_2,M=M_1×M_2,E=E_1+E_2$</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值。</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相乘可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失）</li>
<li>乘以 1 等于原来的数</li>
<li>不满足分配率 <code>1e20*(1e20-1e20)=0.0</code> 但 <code>1e20*1e20-1e20*1e20=NaN</code></li>
<li>除了 infinity 和 NaN，满足单调性，即 a≥b→a×c≥a×b</li>
</ul>
<h2 id="3machine-code">3.Machine code</h2>
<p><strong>Code Forms:</strong></p>
<ul>
<li>Machine Code: The byte-level programs that a processor executes</li>
<li>Assembly Code: A text representation of machine code</li>
</ul>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250225153337138.png" alt="image-20250225153337138" style="zoom:33%;" />
<p><strong>Programmer-Visible State</strong></p>
<ul>
<li>
<p><strong>PC: Program counter</strong></p>
<ul>
<li>
<p>Address of next instruction</p>
</li>
<li>
<p>Called “RIP” (x86-64)</p>
</li>
</ul>
</li>
<li>
<p><strong>Register</strong> <strong>file</strong></p>
<ul>
<li>Heavily used program data</li>
</ul>
</li>
<li>
<p><strong>Condition</strong> <strong>codes</strong></p>
<ul>
<li>
<p>Store status information about most recent arithmetic or logical operation</p>
</li>
<li>
<p>Used for conditional branching</p>
</li>
</ul>
</li>
<li>
<p><strong>Memory</strong></p>
<ul>
<li>
<p>Byte addressable array</p>
</li>
<li>
<p>Code and user data</p>
</li>
<li>
<p>Stack to support procedures</p>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// source code: sum.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">long</span> <span class="nf">plus</span><span class="p">(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sumstore</span><span class="p">(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">t</span> <span class="o">=</span> <span class="nf">plus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sumstore:
</span></span><span class="line"><span class="cl">    pushq   %rbx
</span></span><span class="line"><span class="cl">    movq    %rbx, %rbx
</span></span><span class="line"><span class="cl">    call    plus
</span></span><span class="line"><span class="cl">    movq    %rax, (%rbx)
</span></span><span class="line"><span class="cl">    popq    %rbx
</span></span><span class="line"><span class="cl">    ret
</span></span><span class="line"><span class="cl">//Obtain (on shark machine) with command
</span></span><span class="line"><span class="cl">//gcc –Og –S sum.c
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="汇编入门basic">汇编入门(Basic)</h3>
<p>前面我们简要了解了一下程序执行的基本过程，也对汇编有了一点点认识，这一节我们从寄存器的相关知识讲起，介绍汇编的基本知识。这部分内容虽然在实际编程中几乎用不到，但是对于后面内容的理解非常重要。</p>
<p>x86-64 架构中的整型寄存器如下图所示（暂时不考虑浮点数的部分）</p>
<p><img src="https://wdxtub.com/images/csapp/14611562175522.jpg" alt="img"></p>
<p>仔细看看寄存器的分布，我们可以发现有不同的颜色以及不同的寄存器名称，黄色部分是 16 位寄存器，也就是 16 位处理器 8086 的设计，然后绿色部分是 32 位寄存器（这里我是按照比例画的），给 32 位处理器使用，而蓝色部分是为 64 位处理器设计的。这样的设计保证了令人震惊的向下兼容性，几十年前的 x86 代码现在仍然可以运行！</p>
<p><strong>当填入寄存器时，填充32位会重置前32位为0，但是填充更低位数不会改变高阶位数。</strong></p>
<p>前六个寄存器(%rax, %rbx, %rcx, %rdx, %rsi, %rdi)称为通用寄存器（General Purpose Registers, GPRs），通常用于存储数据、指针或函数参数。除了专门的用途之外，它们也可以作为临时存储空间来处理计算任务。x86-64 架构的通用寄存器包括：</p>
<ul>
<li>
<p><strong>%rax</strong>：累加寄存器</p>
<ul>
<li>主要用于算术运算、返回值存储以及一些特定指令的操作。</li>
<li><strong>返回值</strong>：调用一个函数时，%rax 通常存储返回值。</li>
<li>例如，<code>mov %rax, %rdi</code> 表示将 %rax 寄存器的值移动到 %rdi。</li>
</ul>
</li>
<li>
<p><strong>%rbx</strong>：基址寄存器</p>
<ul>
<li>主要用于存储基地址（在基址寻址模式下），也是函数调用约定中保存的寄存器。</li>
<li>在有些操作系统中，%rbx 是一个&quot;被保护的&quot;寄存器，意味着它在函数调用中不会被修改。</li>
</ul>
</li>
<li>
<p><strong>%rcx</strong>：计数寄存器</p>
<ul>
<li>常用于循环计数、位移操作等。</li>
<li>在某些指令（如<code>rep</code>指令）中，%rcx 作为计数器。</li>
<li>例如，<code>mov %rcx, %rax</code> 将 %rcx 的值传递给 %rax。</li>
</ul>
</li>
<li>
<p><strong>%rdx</strong>：数据寄存器</p>
<ul>
<li>主要用于乘法、除法等操作。</li>
<li>在乘法或除法指令中，%rdx 通常会与 %rax 配合使用（例如，除法时，商存储在 %rax，余数存储在 %rdx）。</li>
</ul>
</li>
<li>
<p><strong>%rsi</strong>：源索引寄存器</p>
<ul>
<li>通常用于存储源数据的地址。</li>
<li>在字符串操作（如 <code>movs</code>, <code>stos</code>）或内存复制操作中，%rsi 常作为源操作数寄存器。</li>
</ul>
</li>
<li>
<p><strong>%rdi</strong>：目标索引寄存器</p>
<ul>
<li>通常用于存储目标数据的地址。</li>
<li>在函数调用中，%rdi 存储传递给函数的第一个参数。</li>
</ul>
</li>
<li>
<p><strong>%rsp</strong>：栈指针寄存器</p>
<ul>
<li>用于指示栈的顶部。栈是用来存储局部变量、函数返回地址等的内存区域。</li>
<li>每当数据被推送到栈上时，%rsp 的值会减少；弹出数据时，%rsp 的值会增加。</li>
</ul>
</li>
<li>
<p><strong>%rbp</strong>：基指针寄存器</p>
<ul>
<li>用于函数调用时存储栈帧的基址，尤其在访问函数参数和局部变量时，它提供一个固定的基地址。</li>
<li>%rbp 常用作函数调用时栈帧的基指针。</li>
</ul>
</li>
<li>
<p><strong>%r8 到 %r15</strong>：扩展的通用寄存器</p>
<ul>
<li>x86-64 架构提供了额外的 8 个 64 位通用寄存器（%r8 到 %r15），用于处理更多的参数传递、临时数据存储等任务。</li>
</ul>
  <img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250225185959355.png" alt="image-20250225185959355" style="zoom:33%;" />
</li>
</ul>
<p>而 %rsp(%esp) 和 %rbp(%ebp) 则是作为栈指针和基指针来使用的。下面我们通过 <code>movq</code> 这个指令来了解操作数的三种基本类型：立即数(Imm,e.g.$0x4)、寄存器值(Reg)和内存值(Mem)。</p>
<p>对于 <code>movq</code> 指令来说，需要源操作数和目标操作数，源操作数可以是立即数、寄存器值或内存值的任意一种，但目标操作数只能是寄存器值或内存值。指令的具体格式可以这样写 <code>movq [Imm|Reg|Mem], [Reg|Mem]</code>，第一个是源操作数，第二个是目标操作数，例如：</p>
<ul>
<li><code>movq Imm, Reg</code> -&gt; <code>mov $0x5, %rax</code> -&gt; <code>temp = 0x5;</code></li>
<li><code>movq Imm, Mem</code> -&gt; <code>mov $0x5, (%rax)</code> -&gt; <code>*p = 0x5;</code></li>
<li><code>movq Reg, Reg</code> -&gt; <code>mov %rax, %rdx</code> -&gt; <code>temp2 = temp1;</code></li>
<li><code>movq Reg, Mem</code> -&gt; <code>mov %rax, (%rdx)</code> -&gt; <code>*p = temp;</code></li>
<li><code>movq Mem, Reg</code> -&gt; <code>mov (%rax), %rdx</code> -&gt; <code>temp = *p;</code></li>
</ul>
<p>这里有一种情况是不存在的，没有 <code>movq Mem, Mem</code> 这个方式，也就是说，我们没有办法用一条指令完成内存间的数据交换。</p>
<p>上面的例子中有些操作数是带括号的，括号的意思就是寻址，这也分两种情况：</p>
<ul>
<li>普通模式，(R)，相当于 <code>Mem[Reg[R]]</code>，也就是说寄存器 R 指定内存地址，类似于 C 语言中的指针，语法为：<code>movq (%rcx), %rax</code> 也就是说以 %rcx 寄存器中存储的地址去内存里找对应的数据，存到寄存器 %rax 中</li>
<li>移位模式，D(R)，相当于 <code>Mem[Reg[R]+D]</code>，寄存器 R 给出起始的内存地址，然后 D 是偏移量，语法为：<code>movq 8(%rbp),%rdx</code> 也就是说以 %rbp 寄存器中存储的地址再加上 8 个偏移量去内存里找对应的数据，存到寄存器 %rdx 中</li>
</ul>
<p>因为寻址这个内容比较重要，所以多说两句，不然之后接触指针会比较吃力。对于寻址来说，比较通用的格式是 <code>D(Rb, Ri, S)</code> -&gt; <code>Mem[Reg[Rb]+S*Reg[Ri]+D]</code>，其中：</p>
<ul>
<li><code>D</code> - 常数偏移量</li>
<li><code>Rb</code> - 基寄存器</li>
<li><code>Ri</code> - 索引寄存器，不能是 %rsp</li>
<li><code>S</code> - 系数</li>
</ul>
<p>除此之外，还有如下三种特殊情况</p>
<ul>
<li><code>(Rb, Ri)</code> -&gt; <code>Mem[Reg[Rb]+Reg[Ri]]</code></li>
<li><code>D(Rb, Ri)</code> -&gt; <code>Mem[Reg[Rb]+Reg[Ri]+D]</code></li>
<li><code>(Rb, Ri, S)</code> -&gt; <code>Mem[Reg[Rb]+S*Reg[Ri]]</code></li>
</ul>
<p>我们通过具体的例子来巩固一下，这里假设 %rdx 中的存着 <code>0xf000</code>，%rcx 中存着 <code>0x0100</code>，那么</p>
<ul>
<li><code>0x8(%rdx)</code> = <code>0xf000</code> + <code>0x8</code> = <code>0xf008</code></li>
<li><code>(%rdx, %rcx)</code> = <code>0xf000</code> + <code>0x100</code> = <code>0xf100</code></li>
<li><code>(%rdx, %rcx, 4)</code> = <code>0xf000</code> + <code>4*0x100</code> = <code>0xf400</code></li>
<li><code>0x80(, %rdx, 2)</code> = <code>2*0xf000</code> + <code>0x80</code> = <code>0x1e080</code></li>
<li><code>(, %edx, 2)</code> = <code>(0, %rdx, 2)</code> = <code>0 + 2*0xf000</code></li>
</ul>
<p>了解了寻址之后，我们来看看运算指令，这里以 <code>leaq</code> 指令为例子。具体格式为 <code>leaq Src, Dst</code>，其中 <code>Src</code> 是地址的表达式，然后把计算的值存入 <code>Dst</code> 指定的寄存器，也就是说，因为<code>leaq</code>只计算内存地址并不访问它，所以<code>leaq</code>可以将普通数字当作内存计算，类似于 <code>p = &amp;x[i];</code>，也可以计算<code>x + k*y</code>的代数形式。我们来看一个具体的例子，假设一个 C 函数是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">long</span> <span class="nf">m12</span><span class="p">(</span><span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">12</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的汇编代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">leaq (%rdi, %rdi, 2), %rax # t &lt;- x+x*2
</span></span><span class="line"><span class="cl">salq $2, %rax              # return t &lt;&lt; 2
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到是直接对 %rdi 寄存器中存的数据（地址）进行运算，然后赋值给 %rax。最后给出一些常见的算术运算指令，注意参数的顺序，而且对于有符号和无符号数都是一样的，更多的信息可以参考 Intel 官方文档。</p>
<p>需要两个操作数的指令</p>
<ul>
<li><code>addq Src, Dest</code> -&gt; <code>Dest = Dest + Src</code></li>
<li><code>subq Src, Dest</code> -&gt; <code>Dest = Dest - Src</code></li>
<li><code>imulq Src, Dest</code> -&gt; <code>Dest = Dest * Src</code></li>
<li><code>salq Src, Dest</code> -&gt; <code>Dest = Dest &lt;&lt; Src</code></li>
<li><code>sarq Src, Dest</code> -&gt; <code>Dest = Dest &gt;&gt; Src</code></li>
<li><code>shrq Src, Dest</code> -&gt; <code>Dest = Dest &gt;&gt; Src</code></li>
<li><code>xorq Src, Dest</code> -&gt; <code>Dest = Dest ^ Src</code></li>
<li><code>andq Src, Dest</code> -&gt; <code>Dest = Dest &amp; Src</code></li>
<li><code>orq Src, Dest</code> -&gt; <code>Dest = Dest | Src</code></li>
</ul>
<p>需要一个操作数的指令</p>
<ul>
<li><code>incq Dest</code> -&gt; <code>Dest = Dest + 1</code></li>
<li><code>decq Dest</code> -&gt; <code>Dest = Dest - 1</code></li>
<li><code>negq Dest</code> -&gt; <code>Dest = -Dest</code></li>
<li><code>notq Dest</code> -&gt; <code>Dest = ~Dest</code></li>
</ul>
<p><strong>The meaning of different suffixs</strong></p>
<ul>
<li>
<p><strong><code>b</code> (byte)</strong>:</p>
<ul>
<li>
<p>Refers to 8-bit operands (1 byte).</p>
</li>
<li>
<p>Example: <code>addb</code>, <code>subb</code>, <code>movb</code>.</p>
</li>
<li>
<p>The <code>b</code> suffix indicates that the instruction is operating on 8-bit values.</p>
</li>
</ul>
</li>
<li>
<p><strong><code>w</code> (word)</strong>:</p>
<ul>
<li>
<p>Refers to 16-bit operands (2 bytes).</p>
</li>
<li>
<p>Example: <code>addw</code>, <code>subw</code>, <code>movw</code>.</p>
</li>
<li>
<p>The <code>w</code> suffix is used when dealing with 16-bit data.</p>
</li>
</ul>
</li>
<li>
<p><strong><code>l</code> (long)</strong>:</p>
<ul>
<li>
<p>Refers to 32-bit operands (4 bytes).</p>
</li>
<li>
<p>Example: <code>addl</code>, <code>subl</code>, <code>movl</code>.</p>
</li>
<li>
<p>The <code>l</code> suffix is used for 32-bit values (long integers).</p>
</li>
</ul>
</li>
<li>
<p><strong><code>q</code> (quad)</strong>:</p>
<ul>
<li>
<p>Refers to 64-bit operands (8 bytes).</p>
</li>
<li>
<p>Example: <code>addq</code>, <code>subq</code>, <code>movq</code>.</p>
</li>
<li>
<p>The <code>q</code> suffix is used for 64-bit values (quad-word integers).</p>
</li>
</ul>
</li>
<li>
<p><strong><code>t</code> (ten)</strong>:</p>
<ul>
<li>
<p>Sometimes used in 128-bit instructions, like with <code>movaps</code> for SIMD operations (Single Instruction, Multiple Data).</p>
</li>
<li>
<p>Example: <code>movaps</code> or <code>addps</code>, where <code>ps</code> stands for packed single-precision floating-point operations on 128-bit vectors.</p>
</li>
</ul>
</li>
</ul>
<h3 id="流程控制control">流程控制(Control)</h3>
<p>我们先来回顾一下 x86-64 处理器中不同的寄存器，这一部分很重要，务必要弄明白</p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14611621119083.jpg" alt="img" style="zoom:50%;" />
<p>首先要理解的是，寄存器中存储着当前正在执行的程序的相关信息：</p>
<ul>
<li>临时数据存放在 (%rax, …)</li>
<li>运行时栈的地址存储在 (%rsp) 中</li>
<li>目前的代码控制点存储在 (%rip, …) 中</li>
<li>目前测试的状态放在 CF, ZF, SF, OF 中</li>
</ul>
<h4 id="条件代码condition-codes">条件代码(<strong>Condition codes</strong>)</h4>
<p>最后的四个标识位（CF, ZF, SF, OF）就是用来辅助程序的流程控制的，他们基于最近的算术或逻辑操作结果意思是：</p>
<ul>
<li>CF: Carry Flag (针对无符号数)</li>
<li>ZF: Zero Flag</li>
<li>SF: Sign Flag (针对有符号数)</li>
<li>OF: Overflow Flag (针对有符号数)</li>
</ul>
<p>可以看到以上这四个标识位，表示四种不同的状态，举个例子，假如我们有一条诸如 <code>t = a + b</code> 的语句，汇编之后假设用的是 <code>addq Src, Dest</code>，那么根据这个操作结果的不同，会相应设置上面提到的四个标识位，而因为这个是执行类似操作时顺带尽心设置的，称为<strong>隐式设置(Implicit Setting)</strong>，例如：</p>
<ul>
<li>
<p>如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置(unsigned overflow)</p>
</li>
<li>
<p>如果 t 等于 0，那么 ZF 标识位会被设置</p>
</li>
<li>
<p>如果 t 小于 0，那么 SF 标识位会被设置(as signed)</p>
</li>
<li>
<p>如果 2’s complement(signed) 溢出，那么 OF 标识位会被设置为 1</p>
<p>（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</p>
</li>
</ul>
<p>这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。注意，使用 <code>leaq</code> 指令的话不会进行设置。</p>
<p>除了隐形设置，还可以进行<strong>显式设置(Explicit Setting)</strong>，具体的方法是使用 <code>cmpq</code> 指令，这里的 q 指的是 64 位的地址。具体来说 <code>cmpq Src2(b), Src1(a)</code> 等同于计算 <code>a-b</code>（注意 a b 顺序是颠倒的），然后利用 <code>a-b</code> 的结果来对应进行条件代码的设置：</p>
<ul>
<li>
<p>如果在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置(unsigned)</p>
</li>
<li>
<p>a 和 b 相等时，也就是 <code>a-b</code> 等于零时，ZF 标识位会被设置</p>
</li>
<li>
<p>如果 a &lt; b，也就是 <code>(a-b)&lt;0</code> 时，那么 SF 标识位会被设置(as signed)</p>
</li>
<li>
<p>如果 2’s complement(signed) 溢出，那么 OF 标识位会被设置</p>
<p>（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</p>
</li>
</ul>
<p>另一种进行显式设置的方法是使用 <code>testq</code> 指令，具体来说 <code>testq Src2(b), Src1(a)</code> 等同于计算 <code>a&amp;b</code>并且没有输出地址（注意 a b 顺序是颠倒的），然后利用 <code>a-b</code> 的结果来对应进行条件代码的设置，通常来说会把其中一个操作数作为 mask：</p>
<ul>
<li>当 <code>a&amp;b == 0</code> 时，ZF 标识位会被设置</li>
<li>当 <code>a&amp;b &lt; 0</code> 时，SF 标识位会被设置</li>
</ul>
<p>有了这四个条件码，就可以通过不同的组合方式，来产生不同的条件判断。</p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250225190202878.png" alt="image-20250225190202878" style="zoom:33%;" />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">gt</span> <span class="p">(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	cmpq   %rsi, %rdi   # Compare x:y
</span></span><span class="line"><span class="cl">	setg   %al          # Set when &gt;
</span></span><span class="line"><span class="cl">	movzbl %al, %eax    # Zero rest of %rax
</span></span><span class="line"><span class="cl">	ret
</span></span></code></pre></td></tr></table>
</div>
</div><table>
  <thead>
      <tr>
          <th><strong>Register</strong></th>
          <th><strong>Use(s)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>%rdi</strong></td>
          <td>Argument <strong>x</strong></td>
      </tr>
      <tr>
          <td><strong>%rsi</strong></td>
          <td>Argument <strong>y</strong></td>
      </tr>
      <tr>
          <td><strong>%rax</strong></td>
          <td>Return value</td>
      </tr>
  </tbody>
</table>
<h4 id="条件分支conditional-branches">条件分支(Conditional Branches)</h4>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250225190522755.png" alt="image-20250225190522755" style="zoom:33%;" />
<p>介绍完了条件代码，就可以来看看具体的跳转了，跳转实际上就是根据条件代码的不同来进行不同的操作。我们先来看一个比较原始的例子（编译器没有进行优化）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">long</span> <span class="nf">absdiff</span><span class="p">(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">=</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的汇编代码如下，这里 %rdi 中保存了参数 x，%rsi 中保存了参数 y，而 %rax 一般用来存储返回值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">absdiff:
</span></span><span class="line"><span class="cl">    cmpq    %rsi, %rdi
</span></span><span class="line"><span class="cl">    jle     .L4
</span></span><span class="line"><span class="cl">    movq    %rdi, %rax
</span></span><span class="line"><span class="cl">    subq    %rsi, %rax
</span></span><span class="line"><span class="cl">    ret
</span></span><span class="line"><span class="cl">.L4:    # x &lt;= y
</span></span><span class="line"><span class="cl">    movq    %rsi, %rax
</span></span><span class="line"><span class="cl">    subq    %rdi, %rax
</span></span><span class="line"><span class="cl">    ret
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里我们是要给出两个数的绝对值的差，所以需要判断谁大谁小。考虑到汇编不算特别直观，这里我们用 goto 语句重写一次，基本上就和汇编出来的代码逻辑类似了，方便之后的讲解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">long</span> <span class="nf">absdiff_goto</span><span class="p">(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ntest</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ntest</span><span class="p">)</span> <span class="k">goto</span> <span class="n">Else</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">Done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">Else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">Done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们再看另一种条件语句要如何翻译，比如 <code>val = Test ? Then_Expr : Else_Expr;</code>，重写上面的函数就是：<code>val = x&gt;y ? x-y : y-x;</code></p>
<p>转换成 goto 形式就是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">	<span class="n">ntest</span> <span class="o">=</span> <span class="o">!</span><span class="n">Test</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">ntest</span><span class="p">)</span> <span class="k">goto</span> <span class="n">Else</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">value</span> <span class="o">=</span> <span class="n">Then_Expr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">goto</span> <span class="n">Done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">Else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">val</span> <span class="o">=</span> <span class="n">Else_Expr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">Done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="p">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是实际上汇编出来的代码，并不是这样的，会采用另一种方法来加速分支语句的执行。现在我们先来说一说，为什么分支语句会对性能造成很大的影响。</p>
<p>我们知道现在的 CPU 都是依靠流水线工作的，比方说执行一系列操作需要 ABCDE 五个步骤，那么在执行 A 的时候，实际上执行 B 所需的数据会在执行 A 的同时加载到寄存器中，这样运算器执行外 A，就可以立刻执行 B 而无须等待数据载入。如果程序一直是顺序的，那么这个过程就可以一直进行下去，效率会很高。但是一旦遇到分支，那么可能执行完 A 下一步要执行的是 C，但是载入的数据是 B，这时候就要把流水线清空（因为后面载入的东西都错了），然后重新载入 C 所需要的数据，这就带来了很大的性能影响。为此人们常常用『分支预测』这一技术来解决（分支预测是另一个话题这里不展开），但是对于这类只需要判断一次的条件语句来说，其实有更好的方法。</p>
<p>处理器有一条指令支持 <code>if(Test) Dest &lt;- Src</code> 的操作，也就是说可以不用跳转，利用条件代码来进行赋值，于是编译器在可能的时候会把上面的 goto 程序改成如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">result</span> <span class="o">=</span> <span class="n">Then_Expr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">eval</span> <span class="o">=</span> <span class="n">Else_Expr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">nt</span> <span class="o">=</span> <span class="o">!</span><span class="n">Test</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="n">result</span> <span class="o">=</span> <span class="n">eval</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>具体的做法是：反正一共就两个分支，我都算出行不行，然后利用上面的条件指令来进行赋值，这样就完美避免了因为分支可能带来的性能问题（需要清空流水线），像下面这样，同样 %rdi 中保存了参数 x，%rsi 中保存了参数 y，而 %rax 一般用来存储返回值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">absdiff:
</span></span><span class="line"><span class="cl">    movq    %rdi, %rax  # x
</span></span><span class="line"><span class="cl">    subq    %rsi, %rax  # result = x-y
</span></span><span class="line"><span class="cl">    movq    %rsi, %rdx
</span></span><span class="line"><span class="cl">    subq    %rdi, %rdx  # eval = y-x
</span></span><span class="line"><span class="cl">    cmpq    %rsi, %rdi  # x:y
</span></span><span class="line"><span class="cl">    cmovle  %rdx, %rax  # if &lt;=, result = eval
</span></span><span class="line"><span class="cl">    ret
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个方法好是好，但是也有一些情况并不适用于：</p>
<ul>
<li>Expensive Computation: 因为会把两个分支的运算都提前算出来，如果这两个值都需要大量计算的话，就得不偿失了，所以需要分支中的计算尽量简单。</li>
<li>Risky Computations: 另外在涉及指针操作的时候，如 <code>val = p ? *p : 0;</code>，因为两个分支都会被计算，所以可能导致奇怪问题出现</li>
<li>Computations with side effects: 最后一种就是如果分支中的计算是有副作用的，那么就不能这样弄 <code>val = x &gt; 0 ? x*= 7 : x+= 3;</code>，这种情况下，因为都计算了，那么 x 的值肯定就不是我们想要的了。</li>
</ul>
<h4 id="循环loop">循环(Loop)</h4>
<p>先来看看并不那么常用的 Do-While 语句以及对应使用 goto 语句进行跳转的版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// Do While 的 C 语言代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">long</span> <span class="nf">pcount_do</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Goto 版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">long</span> <span class="nf">pcount_goto</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">loop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数计算参数 x 中有多少位是 1，翻译成汇编如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    movl    $0, %eax    # result = 0
</span></span><span class="line"><span class="cl">.L2:                    # loop:
</span></span><span class="line"><span class="cl">    movq    %rdi, %rdx
</span></span><span class="line"><span class="cl">    andl    $1, %edx    # t = x &amp; 0x1
</span></span><span class="line"><span class="cl">    addq    %rdx, %rax  # result += t
</span></span><span class="line"><span class="cl">    shrq    %rdi        # x &gt;&gt;= 1
</span></span><span class="line"><span class="cl">    jne     .L2         # if (x) goto loop
</span></span><span class="line"><span class="cl">    rep; ret
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 %rdi 中存储的是参数 x，%rax 存储的是返回值。换成更通用的形式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// C Code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">do</span>
</span></span><span class="line"><span class="cl">	<span class="n">Body</span>
</span></span><span class="line"><span class="cl">	<span class="nf">while</span> <span class="p">(</span><span class="n">Test</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Goto Version 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">loop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Body</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">Test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">goto</span> <span class="n">loop</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而对于 While 语句的转换，存在两种形式，对于第一种形式会直接跳到中间，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// C While version
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">Test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">Body</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Goto Version #v1 Used with -Og
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">goto</span> <span class="n">test</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">loop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Body</span>
</span></span><span class="line"><span class="cl"><span class="nl">test</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">Test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Goto Version #v2 Used with -O1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Test</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="n">Body</span>
</span></span><span class="line"><span class="cl">    <span class="nf">while</span><span class="p">(</span><span class="n">Test</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nl">done</span><span class="p">:</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果在编译器中开启 <code>-O1</code> 优化，那么会把 While 先翻译成 Do-While，然后再转换成对应的 Goto 版本，因为 Do-While 语句执行起来更快，更符合 CPU 的运算模型。</p>
<p>接着来看看最常用的 For 循环，也可以一步一步转换成 While 的形式，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// For
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">Init</span><span class="p">;</span> <span class="n">Test</span><span class="p">;</span> <span class="n">Update</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">Body</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="c1">// While Version
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Init</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">Test</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Body</span>
</span></span><span class="line"><span class="cl">	<span class="n">Update</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Switch 语句</p>
<p>最后我们来看看最复杂的 switch 语句，这种类型的语句一次判断会有多种可能的跳转路径（知道 CPU 的分支预测会多抓狂吗）。这里用一个具体的例子来进行讲解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">long</span> <span class="nf">switch_eg</span> <span class="p">(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">,</span> <span class="kt">long</span> <span class="n">z</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">w</span> <span class="o">=</span> <span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">w</span> <span class="o">=</span> <span class="n">y</span><span class="o">/</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// fall through
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">w</span> <span class="o">+=</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="mi">5</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="mi">6</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">w</span> <span class="o">-=</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个例子中包含了大部分比较特殊的情况：</p>
<ul>
<li>共享的条件：5 和 6</li>
<li>fall through：2 也会执行 3 的部分（这个要小心，一般来说不这么搞，如果确定要用，务必写上注释）</li>
<li>缺失的条件：4</li>
</ul>
<p>具体怎么办呢？简单来说，使用跳转表(jtab)（你会发现表的解决方式在很多地方都有用：虚函数，继承甚至动态规划），可能会类似如下汇编代码，这里 %rdi 是参数 x，%rsi 是参数 y，%rdx 是参数 z, %rax 是返回值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">switch_eg:
</span></span><span class="line"><span class="cl">    movq    %rdx, %rcx
</span></span><span class="line"><span class="cl">    cmpq    $6, %rdi    # x:6
</span></span><span class="line"><span class="cl">    ja      .L8
</span></span><span class="line"><span class="cl">    jmp     *.L4(, %rdi, 8)
</span></span></code></pre></td></tr></table>
</div>
</div><p>跳转表为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.section    .rodata
</span></span><span class="line"><span class="cl">    .align 8
</span></span><span class="line"><span class="cl">.L4:
</span></span><span class="line"><span class="cl">    .quad   .L8 # x = 0
</span></span><span class="line"><span class="cl">    .quad   .L3 # x = 1
</span></span><span class="line"><span class="cl">    .quad   .L5 # x = 2
</span></span><span class="line"><span class="cl">    .quad   .L9 # x = 3
</span></span><span class="line"><span class="cl">    .quad   .L8 # x = 4
</span></span><span class="line"><span class="cl">    .quad   .L7 # x = 5
</span></span><span class="line"><span class="cl">    .quad   .L7 # x = 6
</span></span></code></pre></td></tr></table>
</div>
</div><img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250225195059079.png" alt="image-20250225195059079" style="zoom:50%;" />
<p><strong>这里需要注意，我们先跟 6 进行比较（因为 6 是最大的）</strong>，然后利用 <code>ja</code> 指令进行跳转，为什么，因为如果是负数的话，<code>ja</code> 是处理无符号数的，所以负数情况肯定大于 6，于是直接利用 <code>ja</code> 跳转到 default 的分支。</p>
<p>如果存在负数整型，编译器会将整体加上一个偏移值，使之可以只与最大值比较便跳转<code>default</code>。若差值过大则变为决策树。</p>
<p>然后下一句 <code>jmp *.L4(,%rdi, 8) # goto *JTab[x]</code>，是一个间接跳转，通过看上面的跳转列表来进行跳转。</p>
<p>比如说，直接跳转 <code>jmp .L8</code>，就直接跳到 <code>.L8</code> 所在的标签，也就是 x = 0</p>
<p>如果是 <code>jmp *.L4(,%rdi,8)</code> 那么就先找到 <code>.L4</code> 然后往后找 8 个字节（或 8 的倍数），于是就是 0~6 的范围。</p>
<p>通过上面的例子，我们可以大概了解处理 switch 语句的方式：大的 switch 语句会用跳转表，具体跳转时可能会用到决策树（if-elseif-elseif-else）</p>
<h3 id="过程调用procedures">过程调用(Procedures)</h3>
<p>上一节中我们学习了机器是如何利用跳转实现流程控制的，这一节我们来看一个更加复杂的机制：过程调用（也就是调用函数）具体在 CPU 和内存中是怎么实现的。理解之后，对于递归会有更加清晰的认识。</p>
<p>在过程调用中主要涉及三个重要的方面：</p>
<ol>
<li>传递控制：包括如何开始执行过程代码，以及如何返回到开始的地方</li>
<li>传递数据：包括过程需要的参数以及过程的返回值</li>
<li>内存管理：如何在过程执行的时候分配内存，以及在返回之后释放内存</li>
</ol>
<p>以上这三点，都是凭借机器指令实现的</p>
<h4 id="栈结构stack-structure">栈结构(Stack Structure)</h4>
<p>在 x86-64 中，所谓的栈，实际上一块内存区域，这个区域的数据进出满足先进后出的原则。所以栈向低内存地址部分增长，是一个上下颠倒的结构，寄存器<code>%rsp</code>保存着最低位的栈顶地址。</p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250225200007574.png" alt="image-20250225200007574" style="zoom:33%;" />
<p>我们假设一开始 %rsp 为红色，对于 <code>push</code> 操作，对应的是 <code>pushq Src</code> 指令，具体会完成下面三个步骤：</p>
<ol>
<li>从地址 <code>Src</code> 中取出操作数</li>
<li>把 %rsp 中的地址减去 8（也就是到下一个位置）</li>
<li>把操作数写入到 %rsp 的新地址中</li>
</ol>
<p>这个时候 %rsp 就对应下8位。</p>
<p>重来一次，假设一开始 %rsp 为红色，对于 <code>pop</code> 操作，对应的是 <code>popq Dest</code> 指令，具体会完成下面三个步骤：</p>
<ol>
<li>从 %rsp 中存储的地址中读入数据</li>
<li>把 %rsp 中的地址增加 8（回到上一个位置）</li>
<li>把刚才取出来的值放到 <code>Dest</code> 中（这里必须是一个寄存器）</li>
</ol>
<p>这时候 %rsp 就对应上8位。</p>
<h4 id="调用方式calling-conventions">调用方式(<strong>Calling Conventions</strong>)</h4>
<p>如果在一段函数中要调用另一个函数用于赋值，栈可用于保存原函数中的变量值。</p>
<ul>
<li>
<p><strong>Use stack to support procedure call and return</strong></p>
<ul>
<li>
<p><strong>Procedure call:</strong> <strong>call</strong> <strong>label</strong></p>
<ul>
<li>
<p>Push return address on stack</p>
</li>
<li>
<p>Jump to label</p>
</li>
</ul>
</li>
<li>
<p><strong>Return address:</strong></p>
<ul>
<li>
<p>Address of the next instruction right after call</p>
</li>
<li>
<p>Example from disassembly</p>
</li>
</ul>
</li>
<li>
<p><strong>Procedure</strong> <strong>return:</strong> <strong>ret</strong></p>
<ul>
<li>
<p>Pop address from stack</p>
</li>
<li>
<p>Jump to address</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// multstore 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">multstore</span> <span class="p">(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">t</span> <span class="o">=</span> <span class="nf">mult2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// mult2 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">long</span> <span class="nf">mult2</span><span class="p">(</span><span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的汇编代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0000000000400540 &lt;multstore&gt;:
</span></span><span class="line"><span class="cl">    # x 在 %rdi 中，y 在 %rsi 中，dest 在 %rdx 中
</span></span><span class="line"><span class="cl">    400540: push    %rbx            # 通过压栈保存 %rbx
</span></span><span class="line"><span class="cl">    400541: mov     %rdx, %rbx      # 保存 dest
</span></span><span class="line"><span class="cl">    400544: callq   400550 &lt;mult2&gt;  # 调用 mult2(x, y)
</span></span><span class="line"><span class="cl">    # t 在 %rax 中
</span></span><span class="line"><span class="cl">    400549: mov     %rax, (%rbx)    # 结果保存到 dest 中
</span></span><span class="line"><span class="cl">    40054c: pop     %rbx            # 通过出栈恢复原来的 %rbx
</span></span><span class="line"><span class="cl">    40054d: retq                    # 返回
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">0000000000400550 &lt;mult2&gt;:
</span></span><span class="line"><span class="cl">    # a 在 %rdi 中，b 在 %rsi 中
</span></span><span class="line"><span class="cl">    400550: mov     %rdi, %rax      # 得到 a 的值
</span></span><span class="line"><span class="cl">    400553: imul    %rsi, %rax      # a * b
</span></span><span class="line"><span class="cl">    # s 在 %rax 中
</span></span><span class="line"><span class="cl">    400557: retq                    # 返回
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，过程调用是利用栈来进行的，通过 <code>call label</code> 来进行调用（先把返回地址入栈，然后跳转到对应的 label），返回的地址，将是下一条指令的地址，通过 <code>ret</code> 来进行返回（把地址从栈中弹出，然后跳转到对应地址）</p>
<p>我们『单步调试』来看看具体调用的过程</p>
<p><img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14611722773236.jpg" alt="img"></p>
<ol>
<li>在执行到 400544 那一行的时候 %rsp 指向栈顶（存储着栈顶的地址），%rip 指向当前要执行的指令（也就是 400544）</li>
<li>在上一步操作完成之后，因为跳转的关系，%rip 指向 mult2 函数开始的地方（也就是 400550），之前的压栈操作也使得栈顶改变（返回值的位置），于是 %rsp 对应进行改变</li>
<li>接着执行到了 <code>retq</code> 那句，这个时候要做的就是从栈中取出栈顶位置（这样就可以从跳转处继续了），然后对寄存器做对应的修改</li>
<li>最后恢复到原来的 multstore 函数中继续执行</li>
</ol>
<h4 id="passing-data"><strong>Passing data</strong></h4>
<p>我们可以发现，函数调用中会利用 %rax 来保存过程调用的返回值，以便程序继续运行的。这就是基本的过程调用的控制流程。</p>
<p>那么过程调用的参数会放在哪里呢？如果参数没有超过六个，那么会放在：%rdi, %rsi, %rdx, %rcx, %r8, %r9 中。如果超过了，会另外放在一个栈中。而返回值会放在 %rax 中。栈只会在需要的时候释放空间。</p>
<h4 id="managing-local-data"><strong>Managing Local data</strong></h4>
<ul>
<li>
<p><strong>Languages that support recursion</strong></p>
<ul>
<li>
<p>e.g., C, Pascal, Java</p>
</li>
<li>
<p>Code must be [“Reentrant(可重入)”](<a href="https://stackoverflow.com/questions/2799023/what-exactly-is-a-reentrant-function">recursion - What exactly is a reentrant function? - Stack Overflow</a>)</p>
<ul>
<li>Multiple simultaneous instantiations of single procedure</li>
</ul>
</li>
<li>
<p>Need some place to store state of each instantiation</p>
<ul>
<li>
<p>Arguments</p>
</li>
<li>
<p>Local variables</p>
</li>
<li>
<p>Return pointer</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Stack discipline</strong></p>
<ul>
<li>
<p>State for given procedure needed for limited time</p>
<ul>
<li>From when called to when return</li>
</ul>
</li>
<li>
<p>Callee returns before caller does</p>
</li>
</ul>
</li>
<li>
<p><strong>Stack allocated in</strong> <strong>Frames</strong></p>
<ul>
<li>state for single procedure instantiation(实例)</li>
</ul>
</li>
</ul>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250225210218000.png" alt="image-20250225210218000" style="zoom:25%;" />
<p>既然是利用栈来进行函数调用，自然而然就可以推广到递归的情况，而对于每个过程调用来说，都会在栈中分配一个帧 Frames。每一个Stack Frame需要</p>
<ul>
<li>返回信息</li>
<li>本地存储（如果需要）</li>
<li>临时空间（如果需要）</li>
</ul>
<p><strong>Management</strong></p>
<ul>
<li>
<p>Space allocated when enter procedure</p>
<ul>
<li>
<p>“Set-up” code</p>
</li>
<li>
<p>Includes push by <strong>call</strong> instruction</p>
</li>
</ul>
</li>
<li>
<p>Deallocated when return</p>
<ul>
<li>
<p>“Finish” code</p>
</li>
<li>
<p>Includes pop by <strong>ret</strong> instruction</p>
</li>
</ul>
</li>
</ul>
<p>整一帧会在过程调用的时候进行空间分配，然后在返回时进行回收，在 x86-64/Linux 中，栈帧的结构是固定的，当前的要执行的栈中包括：</p>
<ul>
<li>Argument Build: 需要使用的参数</li>
<li>如果不能保存在寄存器中，会把一些本地变量放在这里</li>
<li>已保存的寄存器上下文</li>
<li>老的栈帧的指针(%rbp)（可选）</li>
</ul>
<p>而调用者的栈帧则包括：</p>
<ul>
<li>返回地址（因为 <code>call</code> 指令被压入栈的）</li>
<li>调用所需的参数</li>
</ul>
<p>具体如下图所示：</p>
<div style="text-align: center;">
     <img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250225210520628.png" alt="image-20250225210520628" style="zoom:33%;"/>
     <img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14611733132821.jpg" alt="img" style="zoom:50%;" />
</div>
<h4 id="caller-callee-register-used-for-tempoary-storage"><strong>Caller-Callee: Register used for tempoary storage</strong></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">yoo:
</span></span><span class="line"><span class="cl">	• • •
</span></span><span class="line"><span class="cl">    movq $15213, %rdx
</span></span><span class="line"><span class="cl">    call who
</span></span><span class="line"><span class="cl">    addq %rdx, %rax
</span></span><span class="line"><span class="cl">	• • •
</span></span><span class="line"><span class="cl">    ret
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">who:
</span></span><span class="line"><span class="cl">	• • •
</span></span><span class="line"><span class="cl">	subq $18213, %rdx
</span></span><span class="line"><span class="cl">	• • •
</span></span><span class="line"><span class="cl">    ret
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>yoo</code> is the caller, <code>who</code> is the callee</p>
<ul>
<li>Contents of register <code>%rdx</code> overwritten by <code>who</code>
<ul>
<li>“Caller Saved”
<ul>
<li>Caller saves temporary values in its frame before the call</li>
<li><strong>Caller-saved registers</strong> are used to hold temporary quantities that need not be preserved across calls.</li>
<li>It is the caller&rsquo;s responsibility to push these registers onto the stack or copy them somewhere else <em>if</em> it wants to restore this value after a procedure call.</li>
</ul>
</li>
<li>“Callee Saved”
<ul>
<li><strong>Callee-saved registers</strong> are used to hold long-lived values that should be preserved across calls.</li>
<li>Callee restores them before returning to caller</li>
<li>When the caller makes a procedure call, it can expect that those registers will hold the same value after the callee returns, making it the responsibility of the callee to save them and restore them before returning to the caller. Or to not touch them.</li>
</ul>
</li>
<li>Wrapping up, If the caller wants to ensure that a value in a caller-saved register is preserved across a function call, it can either push it to the stack or save the value in the callee register.</li>
</ul>
</li>
</ul>
<p>To be specific.</p>
<div style="text-align: center;">
    <img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250226163037717.png" alt="image-20250226163037717" style="zoom:33%;" />
    <img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250226163621034.png" alt="image-20250226163621034" style="zoom:33%;"/>
</div>
<ul>
<li>
<p><strong>%rax</strong></p>
<ul>
<li>
<p>Return value</p>
</li>
<li>
<p>Also caller-saved</p>
</li>
<li>
<p>Can be modified by procedure</p>
</li>
</ul>
</li>
<li>
<p><strong>%rdi, &hellip;, %r9</strong></p>
<ul>
<li>
<p>Arguments</p>
</li>
<li>
<p>Also caller-saved</p>
</li>
<li>
<p>Can be modified by procedure</p>
</li>
</ul>
</li>
<li>
<p><strong>%r10, r11</strong></p>
<ul>
<li>
<p>Caller-saved</p>
</li>
<li>
<p>Can be modified by procedure</p>
</li>
</ul>
</li>
<li>
<p><strong>%rbx, %r12, %r13, %r14</strong></p>
<ul>
<li>
<p>Callee-saved</p>
</li>
<li>
<p>Callee must save &amp; restore</p>
</li>
</ul>
</li>
<li>
<p><strong>%rbp</strong></p>
<ul>
<li>
<p>Callee-saved</p>
</li>
<li>
<p>Callee must save &amp; restore</p>
</li>
<li>
<p>May be used as frame pointer</p>
</li>
<li>
<p>Can mix &amp; match</p>
</li>
</ul>
</li>
<li>
<p><strong>%rsp</strong></p>
<ul>
<li>
<p>Special form of callee save</p>
</li>
<li>
<p>Restored to original value upon exit from procedure</p>
</li>
</ul>
</li>
</ul>
<h4 id="递归illustration-of-recursion">递归(<strong>Illustration of Recursion</strong>)</h4>
<p>有了前面的的基础，要理解递归就简单很多了，直接上例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">long</span> <span class="nf">pcount_r</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">pcount_r</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的汇编代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pcount_r:
</span></span><span class="line"><span class="cl">    mov     $0, %eax
</span></span><span class="line"><span class="cl">    testq   %rdi, %rdi
</span></span><span class="line"><span class="cl">    je      .L6
</span></span><span class="line"><span class="cl">    push    %rbx
</span></span><span class="line"><span class="cl">    movq    %rdi, %rbx
</span></span><span class="line"><span class="cl">    andl    $1, %ebx
</span></span><span class="line"><span class="cl">    shrq    %rdi
</span></span><span class="line"><span class="cl">    call    pcount_r
</span></span><span class="line"><span class="cl">    addq    %rbx, %rax #%rax是返回值，%rbx
</span></span><span class="line"><span class="cl">    popq    %rbx
</span></span><span class="line"><span class="cl">.L6:
</span></span><span class="line"><span class="cl">    rep; ret
</span></span></code></pre></td></tr></table>
</div>
</div><p>实际执行的过程中，会不停进行压栈，直到最后返回，所以递归本身就是一个隐式的栈实现，但是系统一般对于栈的深度有限制（每次一都需要保存当前栈帧的各种数据），所以一般来说会把递归转换成显式栈来进行处理以防溢出。</p>
<p>寄存器保存策略也保证了不同过程不会影响相互的数据。递归调用函数本身和调用其他函数没有本质区别。</p>
<h3 id="数据存储data">数据存储(Data)</h3>
<p>上一节我们了解了过程调用是如何用机器代码实现的，这一节我们来看看基本的数据是如何存储在计算机中。</p>
<p>第一讲中我们已经学到，不同的数据类型所需要的字节数是不同的，我们先来回顾一下这个表格：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">数据类型</th>
          <th style="text-align: center">32 位</th>
          <th style="text-align: center">64 位</th>
          <th style="text-align: center">x86-64</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">char</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
      </tr>
      <tr>
          <td style="text-align: center">short</td>
          <td style="text-align: center">2</td>
          <td style="text-align: center">2</td>
          <td style="text-align: center">2</td>
      </tr>
      <tr>
          <td style="text-align: center">int</td>
          <td style="text-align: center">4</td>
          <td style="text-align: center">4</td>
          <td style="text-align: center">4</td>
      </tr>
      <tr>
          <td style="text-align: center">long</td>
          <td style="text-align: center">4</td>
          <td style="text-align: center">8</td>
          <td style="text-align: center">8</td>
      </tr>
      <tr>
          <td style="text-align: center">float</td>
          <td style="text-align: center">4</td>
          <td style="text-align: center">4</td>
          <td style="text-align: center">4</td>
      </tr>
      <tr>
          <td style="text-align: center">double</td>
          <td style="text-align: center">8</td>
          <td style="text-align: center">8</td>
          <td style="text-align: center">8</td>
      </tr>
      <tr>
          <td style="text-align: center">long double</td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">10/16</td>
      </tr>
      <tr>
          <td style="text-align: center">指针</td>
          <td style="text-align: center">4</td>
          <td style="text-align: center">8</td>
          <td style="text-align: center">8</td>
      </tr>
  </tbody>
</table>
<p>我们举几个具体的例子就一目了然了：</p>
<p><img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14611748992035.jpg" alt="img"></p>
<p>既然是连续的地址空间，就有很多不同的访问方式，比方对于 <code>int val[5]</code> 来说</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">引用方式</th>
          <th style="text-align: center">类型</th>
          <th style="text-align: center">值</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"><code>val[4]</code></td>
          <td style="text-align: center"><code>int</code></td>
          <td style="text-align: center">5</td>
      </tr>
      <tr>
          <td style="text-align: center"><code>val</code></td>
          <td style="text-align: center"><code>int *</code></td>
          <td style="text-align: center">x</td>
      </tr>
      <tr>
          <td style="text-align: center"><code>val+1</code></td>
          <td style="text-align: center"><code>int *</code></td>
          <td style="text-align: center">x+4</td>
      </tr>
      <tr>
          <td style="text-align: center"><code>&amp;val[2]</code></td>
          <td style="text-align: center"><code>int *</code></td>
          <td style="text-align: center">x+8</td>
      </tr>
      <tr>
          <td style="text-align: center"><code>val[5]</code></td>
          <td style="text-align: center"><code>int</code></td>
          <td style="text-align: center">?? 越界</td>
      </tr>
      <tr>
          <td style="text-align: center"><code>*(val+1)</code></td>
          <td style="text-align: center"><code>int</code></td>
          <td style="text-align: center">2</td>
      </tr>
      <tr>
          <td style="text-align: center"><code>val+i</code></td>
          <td style="text-align: center"><code>int *</code></td>
          <td style="text-align: center">x + 4i</td>
      </tr>
  </tbody>
</table>
<p>Array Loop Example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">zincr</span><span class="p">(</span><span class="n">zip_dig</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ZLEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  # %rdi = z
</span></span><span class="line"><span class="cl">  movl    $0, %eax          #   i = 0
</span></span><span class="line"><span class="cl">  jmp     .L3               #   goto middle
</span></span><span class="line"><span class="cl">.L4:                        # loop:
</span></span><span class="line"><span class="cl">  addl    $1, (%rdi,%rax,4) #   z[i]++
</span></span><span class="line"><span class="cl">  addq    $1, %rax          #   i++
</span></span><span class="line"><span class="cl">.L3:                        # middle
</span></span><span class="line"><span class="cl">  cmpq    $4, %rax          #   i:4
</span></span><span class="line"><span class="cl">  jbe     .L4               #   if &lt;=, goto loop
</span></span><span class="line"><span class="cl">  rep; ret
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="多维数组multidimensional-nested-arrays">多维数组(<strong>Multidimensional (Nested) Arrays</strong>)</h4>
<p>对于多维的数组，基本形式是 <code>T A[R][C]</code>，R 是行，C 是列，如果类型 T 占 K 个字节的话，那么数组所需要的内存是 <code>R*C*K</code> 字节。具体在内存里的排列方式如下：</p>
<p><img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14611757048510.jpg" alt="img"></p>
<p>具体访问的方式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get_a_digit</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">dig</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的汇编代码为，这里假设 C = 5</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">leaq    (%rdi, %rdi, 4), %rax   # 5 * index
</span></span><span class="line"><span class="cl">addl    %rax, %rsi              # 5 * index + dig
</span></span><span class="line"><span class="cl">movl    A(, %rsi, 4), %eax      # M[A + 4*(5*index+dig)]
</span></span></code></pre></td></tr></table>
</div>
</div><p>还有另外一种组合数组的方式，不是连续分配，而是存储每个数组的起始地址。与之前连续分配唯一不同之处在于计算元素位置时候不同行对应不连续的起始地址（可能分散在内存的不同部分）。这两种方式在 C 语言中看起来差不多，但对应的汇编代码则完全不同。</p>
<ul>
<li>
<p><strong>Array Elements</strong></p>
<ul>
<li>
<p><strong>A[i][j]</strong> is element of type <em>T,</em> which requires <em>K</em> bytes, long C a row.</p>
</li>
<li>
<p>Address <strong>A +</strong> <em>i</em> * (<em>C</em> * <em>K</em>) + <em>j</em> * <em>K =</em> <em>A +</em> (<em>i * C + j</em>)** K*</p>
</li>
</ul>
</li>
</ul>
<h4 id="结构体structures">结构体(Structures)</h4>
<p>结构体是 C 语言中非常常用的一种机制，具体在内存中是如何存放的呢？我们通过具体的例子来进行学习。比如我们有这样一个结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">rec</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>       
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">rect</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么在内存中的排列是</p>
<p><img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14611816137150.jpg" alt="img"></p>
<p>如果我们换一下结构体元素的排列顺序，可能就会出现和我们预想不一样的结果，比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">S1</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为需要对齐的缘故，所以具体的排列是这样的：</p>
<p><img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14611821730508.jpg" alt="img"></p>
<p>具体对齐的原则是，对于结构体前部的数据，只需要与下一个类型对齐，及在下一个数据字节数的倍数处写入数据。而对于最后一个数据，只需要保证结构体全长是结构体中最大的数据类型的字节数的倍数即可。</p>
<p>为什么要这样呢，因为内存访问通常来说是 4 或者 8 个字节位单位的，不对齐的话访问起来效率不高。具体来看的话，是这样：</p>
<ul>
<li>1 字节：char, …
<ul>
<li>没有地址的限制</li>
</ul>
</li>
<li>2 字节：short, …
<ul>
<li>地址最低的 1 比特必须是 <code>0</code></li>
</ul>
</li>
<li>4 字节：int, float, …
<ul>
<li>地址最低的 2 比特必须是 <code>00</code></li>
</ul>
</li>
<li>8 字节：double, long, char *, …
<ul>
<li>地址最低的 3 比特必须是 <code>000</code></li>
</ul>
</li>
<li>16 字节：long double (GCC on Linux)
<ul>
<li>地址最低的 4 比特必须是 <code>0000</code></li>
</ul>
</li>
</ul>
<p>对于一个结构体来说，所占据的内存空间必须是最大的类型所需字节的倍数，所以可能需要占据更多的空间，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">S2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">double</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://wdxtub.com/images/csapp/14611824112595.jpg" alt="img"></p>
<p>根据这种特点，在设计结构体的时候可以采用一些技巧。例如，要把大的数据类型放到前面，加入我们有两个结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">S4</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">S5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的排列是：</p>
<p><img src="https://wdxtub.com/images/csapp/14611827570059.jpg" alt="img"></p>
<p>这样我们就通过不同的排列，节约了 4 个字节空间，如果这个结构体要被复制很多次，这也是很可观的内存优化。</p>
<h3 id="advanced-topics"><strong>Advanced Topics</strong></h3>
<h4 id="内存分布缓冲区溢出memory-layoutbuffer-overflow">内存分布&amp;缓冲区溢出(Memory Layout&amp;Buffer Overflow)</h4>
<p>这一节是机器代码的最后一部分，主要说说由缓冲区溢出引起的攻防大战。我们先来看看程序在内存中是如何组织的（x86-64 Linux）</p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250226171704107.png" alt="image-20250226171704107" style="zoom:33%;" />
<p>最上面是运行时栈，有 8MB 的大小限制，一般用来保存局部变量。然后是堆，动态的内存分配会在这里处理，例如 <code>malloc()</code>, <code>calloc()</code>, <code>new()</code> 等。然后是数据，指的是静态分配的数据，比如说全局变量，静态变量，常量字符串。最后是共享库等可执行的机器指令，这一部分是只读的。</p>
<p>可以见到，栈在最上面，也就是说，栈再往上就是另一个程序的内存范围了，这种时候我们就可以通过这种方式修改内存的其他部分了。</p>
<p>举个例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">struct_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="nf">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">volatile</span> <span class="kt">struct_t</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1073741824</span><span class="p">;</span> <span class="c1">// 可能会越界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不同的 i 可能的执行结果是：</p>
<ul>
<li><code>fun(0)</code> -&gt; 3.14</li>
<li><code>fun(1)</code> -&gt; 3.14</li>
<li><code>fun(2)</code> -&gt; 3.1399998664856</li>
<li><code>fun(3)</code> -&gt; 2.00000061035156</li>
<li><code>fun(4)</code> -&gt; 3.14</li>
<li><code>fun(6)</code> -&gt; Segmentation fault</li>
</ul>
<p>之所以会产生这种错误，是因为访问内存的时候跨过了数组本身的界限修改了 d 的值。你没看错，这是个大问题！如果不检查输入字符串的长度，就很容易出现这种问题，尤其是针对在栈上有界限的字符数组。</p>
<p>在 Unix 中，<code>gets()</code> 函数的实现是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// 从 stdin 中获取输入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">char</span> <span class="o">*</span><span class="nf">gets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">getchar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="n">EOF</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span> <span class="o">=</span> <span class="nf">getchar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到并没有去检测最多能读入多少字符（于是很容易出问题），类似的情况还在 <code>strcpy</code>, <code>strcat</code>, <code>scanf</code>, <code>fscanf</code>, <code>sscanf</code> 中出现。比如说</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">echo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// 太小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">call_echo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">echo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们来测试一下这个函数，可能的结果是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">unix&gt; ./echodemo
</span></span><span class="line"><span class="cl"> Input: <span class="m">012345678901234567890123</span>
</span></span><span class="line"><span class="cl">Output: <span class="m">012345678901234567890123</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">unix&gt; ./echodemo
</span></span><span class="line"><span class="cl"> Input: <span class="m">0123456789012345678901234</span>
</span></span><span class="line"><span class="cl">Segmentation Fault
</span></span></code></pre></td></tr></table>
</div>
</div><p>为什么明明在 <code>echo()</code> 中声明 <code>buf</code> 为 4 个 char，居然一开始输入这么多都没问题？我们到汇编代码里去看看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">00000000004006cf &lt;echo&gt;:
</span></span><span class="line"><span class="cl">    4006cf: 48 83 ec 18         sub   $0x18, %rsp
</span></span><span class="line"><span class="cl">    4006d3: 48 89 e7            mov   %rsp, %rdi
</span></span><span class="line"><span class="cl">    4006d6: e8 a5 ff ff ff      callq 400680 &lt;gets&gt;
</span></span><span class="line"><span class="cl">    4006db: 48 89 e7            mov   %rsp, %rdi
</span></span><span class="line"><span class="cl">    4006de: e8 3d fe ff ff      callq 400520 &lt;puts@plt&gt;
</span></span><span class="line"><span class="cl">    4006e3: 48 83 c4 18         add   $0x18, %rsp
</span></span><span class="line"><span class="cl">    4006e7: c3                  retq
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># call_echo 部分
</span></span><span class="line"><span class="cl">    4006e8: 48 83 ec 08         sub   $0x8, %rsp
</span></span><span class="line"><span class="cl">    4006ec: b8 00 00 00 00      mov   $0x0, %eax
</span></span><span class="line"><span class="cl">    4006f1: e8 d9 ff ff ff      callq 4006cf &lt;echo&gt;
</span></span><span class="line"><span class="cl">    4006f6: 48 83 c4 08         add   $0x8, %rsp
</span></span><span class="line"><span class="cl">    4006fa: c3                  retq
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们看 <code>4006cf</code> 这一行，可以发现实际上给 %rsp 分配了 0x18 的空间，所以可以容纳不止 4 个 char。</p>
<p>在调用 <code>gets</code> 函数之前（第 <code>4006d6</code> 行），内存中栈帧示意图为：</p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14611853013958.jpg" alt="img" style="zoom:33%;" />
<p>结合上面代码可以看到，<code>call_echo</code> 栈帧中保存着调用之前执行指令的地址 <code>4006f6</code>，用于返回之后继续执行。我们输入字符串 <code>01234567890123456789012</code> 之后，栈帧中缓冲区被填充，如下：</p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14611855170102.jpg" alt="img" style="zoom:33%;" />
<p>虽然缓冲区溢出了，但是并没有损害当前的状态，程序还是可以继续运行（也就是没有出现段错误），但是如果再多一点的话，也就是输入 <code>0123456789012345678901234</code>，内存中的情况是这样的：</p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14611856222781.jpg" alt="img" style="zoom:33%;" />
<p>就把返回地址给覆盖掉了，当 <code>echo</code> 执行完成要回到 <code>call_echo</code> 函数时，就跳转到 <code>0x400034</code> 这个内容未知的地址中了。也就是说，通过缓冲区溢出，我们可以在程序返回时跳转到任何我们想要跳转到的地方！攻击者可以利用这种方式来执行恶意代码！</p>
<p>那么我们现在来看看，怎么处理缓冲区溢出攻击，有几种方式：</p>
<ol>
<li>好好写代码，尽量不让缓冲区异常</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cm">/* Echo Line */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">echo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>  <span class="cm">/* Way too small! */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong>fgets</strong> instead of <strong>gets</strong></p>
</li>
<li>
<p><strong>strncpy</strong> instead of <strong>strcpy</strong></p>
</li>
<li>
<p>Don’t use <strong>scanf</strong> with <strong>%s</strong> conversion specification</p>
<ul>
<li>
<p>Use <strong>fgets</strong> to read the string</p>
</li>
<li>
<p>Or use <strong>%ns</strong> where <strong>n</strong> is a suitable integer</p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>程序容易出问题，那么提供系统层级的保护</p>
<ul>
<li>
<p>In traditional x86, can mark region of memory as either “read-only” or “writeable”</p>
<ul>
<li>Can execute anything readable</li>
</ul>
</li>
<li>
<p>X86-64 added explicit “execute” permission</p>
</li>
<li>
<p>Stack marked as non-executable</p>
</li>
</ul>
</li>
<li>
<p>编译器也可以来个认证(stack canaries)</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">echo: # Setting up canary
</span></span><span class="line"><span class="cl">	. . .
</span></span><span class="line"><span class="cl">	movq	%fs:40, %rax  # Get canary
</span></span><span class="line"><span class="cl">	movq	%rax, 8(%rsp) # Place on stack
</span></span><span class="line"><span class="cl">	xorl	%eax, %eax    # Erase canary
</span></span><span class="line"><span class="cl">	. . .
</span></span><span class="line"><span class="cl">echo: # Checking canary
</span></span><span class="line"><span class="cl">	. . .
</span></span><span class="line"><span class="cl">	movq	8(%rsp), %rax     # Retrieve from stack
</span></span><span class="line"><span class="cl">	xorq	%fs:40, %rax      # Compare to canary
</span></span><span class="line"><span class="cl">	je	.L6               # If same, OK
</span></span><span class="line"><span class="cl">	call	__stack_chk_fail  # FAIL
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是，除了缓冲区溢出，还有另一种攻击的方式，称为返回导向编程。可以利用修改已有的代码，来绕过系统和编译器的保护机制，攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。每一段 gadget 通常结束于 return 指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。</p>
<p>具体利用缓冲区进行攻击的例子，会在<a href="https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/2016/04/16/thick-csapp-lab-3/">【读厚 CSAPP】III Attack Lab</a> 中进行讲解，这里不再赘述。</p>
<h4 id="gdb-from-csapp-310">GDB from CSAPP 3.10</h4>
<ol>
<li>run <code>OBJDUMP</code> to get a disassembled version of the programme</li>
<li>set breakpoints near points of interest in the programme.</li>
<li>if breakpoint is hit, the programme will halt and return control control to th euser. From breakpoint, we can examine different registers and memory locations in various formats. We can also single-step the programme, running just a few instructions a time, or we can proceed to the next breakpoint.</li>
</ol>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250226202959221.png" alt="image-20250226202959221" style="zoom:80%;" />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">p $rax  # 打印寄存器 rax 的值
</span></span><span class="line"><span class="cl">p $rsp  # 打印栈指针的值
</span></span><span class="line"><span class="cl">p/x $rsp  # 打印栈指针的值，以十六进制显示
</span></span><span class="line"><span class="cl">p/d $rsp  # 打印栈指针的值，以十进制显示
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">x/2x $rsp  # 以十六进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。
</span></span><span class="line"><span class="cl">x/2d $rsp # 以十进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。
</span></span><span class="line"><span class="cl">x/2c $rsp # 以字符格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。
</span></span><span class="line"><span class="cl">x/s $rsp # 把栈指针指向的内存位置 M[%rsp] 当作 C 风格字符串来查看。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">x/b $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 1 字节。
</span></span><span class="line"><span class="cl">x/h $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 2 字节（半字）。
</span></span><span class="line"><span class="cl">x/w $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 4 字节（字）。
</span></span><span class="line"><span class="cl">x/g $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 8 字节（双字）。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">info registers  # 打印所有寄存器的值
</span></span><span class="line"><span class="cl">info breakpoints  # 打印所有断点的信息
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">delete breakpoints 1  # 删除第一个断点，可以简写为 d 1
</span></span></code></pre></td></tr></table>
</div>
</div><p>这些命令在 <code>/</code> 后面的后缀（如 <code>2x</code>、<code>2d</code>、<code>s</code>、<code>g</code>、<code>20c</code>）指定了查看内存的方式和数量。具体来说：</p>
<ul>
<li>
<p>第一个数字（如 <code>2</code>、<code>20</code>）指定要查看的单位数量。</p>
</li>
<li>
<p>第二个字母（如 <code>x</code>、<code>d</code>、<code>s</code>、<code>g</code>、<code>c</code>）指定单位类型和显示格式，其中：</p>
<ul>
<li>
<p><code>c</code> / <code>d</code> / <code>x</code> 分别代表以字符 / 十进制 / 十六进制格式显示内存内容。</p>
</li>
<li>
<p><code>s</code> 代表以字符串格式显示内存内容。</p>
</li>
<li>
<p><code>b</code> / <code>h</code> / <code>w</code> / <code>g</code> 分别代表以 1 / 2 / 4 / 8 字节为单位（<code>unit</code>）显示内存内容。</p>
<p>当使用 <code>x/b</code>、<code>x/h</code>、<code>x/w</code>、<code>x/g</code> 时，<code>unit</code> 会保留对应改变，直到你再次使用这些命令。</p>
</li>
</ul>
</li>
</ul>
<h2 id="4程序优化code-optimization">4.程序优化(Code Optimization)</h2>
<p>前面了解了许多机器代码以及程序执行机制的相关知识，这一节我们来学习如何利用这些性质来优化代码。</p>
<ul>
<li>用好编译器的不同参数设定</li>
<li>写对编译器友好的代码，尤其是过程调用和内存引用，时刻注意内层循环</li>
<li>根据机器来优化代码，包括利用指令级并行、避免不可以预测的分支以及有效利用缓存</li>
</ul>
<h3 id="通用技巧">通用技巧</h3>
<p>即使是常数项系数的操作，同样可能影响性能。性能的优化是一个多层级的过程：算法、数据表示、过程和循环，都是需要考虑的层次。于是，这就要求我们需要对系统有一定的了解，例如：</p>
<ul>
<li>程序是如何编译和执行的</li>
<li>现代处理器和内存是如何工作的</li>
<li>如何衡量程序的性能以及找出瓶颈</li>
<li>如何保持代码模块化的前提下，提高程序性能</li>
</ul>
<p>最根源的优化是对编译器的优化，比方说再寄存器分配、代码排序和选择、死代码消除、效率提升等方面，都可以由编译器做一定的辅助工作。</p>
<p>但是因为这毕竟是一个自动的过程，而代码本身可以非常多样，在不能改变程序行为的前提下，很多时候编译器的优化策略是趋于保守的。并且大部分用来优化的信息来自于过程和静态信息，很难充分进行动态优化。</p>
<p>接下来会介绍一些我们自己需要注意的地方，而不是依赖处理器或者编译器来解决。</p>
<h3 id="代码移动">代码移动</h3>
<p>如果一个表达式总是得到同样的结果，最好把它移动到循环外面，这样只需要计算一次。编译器有时候可以自动完成，比如说使用 <code>-O1</code> 优化。一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">set_row</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里 <code>n*i</code> 是重复被计算的，可以放到循环外面</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">[</span><span class="n">ni</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="减少计算强度">减少计算强度</h3>
<p>用更简单的表达式来完成用时较久的操作，例如 <code>16*x</code> 就可以用 <code>x &lt;&lt; 4</code> 代替，一个比较明显的例子是，可以把乘积转化位一系列的加法，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="p">[</span><span class="n">ni</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以把 <code>n*i</code> 用加法代替，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ni</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="p">[</span><span class="n">ni</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">ni</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="公共子表达式">公共子表达式</h3>
<p>可以重用部分表达式的计算结果，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Sum neighbors of i, j */</span>
</span></span><span class="line"><span class="cl"><span class="n">up</span> <span class="o">=</span>    <span class="n">val</span><span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">j</span>  <span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">down</span> <span class="o">=</span>  <span class="n">val</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">j</span>  <span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">left</span> <span class="o">=</span>  <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">n</span>     <span class="o">+</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">right</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">n</span>     <span class="o">+</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">sum</span> <span class="o">=</span> <span class="n">up</span> <span class="o">+</span> <span class="n">down</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以优化为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">inj</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">up</span> <span class="o">=</span>    <span class="n">val</span><span class="p">[</span><span class="n">inj</span> <span class="o">-</span> <span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">down</span> <span class="o">=</span>  <span class="n">val</span><span class="p">[</span><span class="n">inj</span> <span class="o">+</span> <span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">left</span> <span class="o">=</span>  <span class="n">val</span><span class="p">[</span><span class="n">inj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">right</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">inj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">sum</span> <span class="o">=</span> <span class="n">up</span> <span class="o">+</span> <span class="n">down</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然说，现代处理器对乘法也有很好的优化，但是既然可以从 3 次乘法运算减少到只需要 1 次，为什么不这样做呢？蚂蚁再小也是肉嘛。</p>
<h3 id="小心过程调用">小心过程调用</h3>
<p>我们先来看一段代码，找找有什么问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lower1</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;Z&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>问题在于，在字符串长度增加的时候，时间复杂度是二次方的！每次循环中都会调用一次 <code>strlen(s)</code>，而这个函数本身需要通过遍历字符串来取得长度，因此时间复杂度就成了二次方。</p>
<p>可以怎么优化呢？简单，那么只计算一次就好了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lower2</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;Z&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为什么编译器不能自动把这个过程调用给移到外面去呢？</p>
<p>前面说过，编译器的策略必须是保守的，因为过程调用之后所发生的事情是不可控的，所以不能直接改变代码逻辑，比方说，假如 <code>strlen</code> 这个函数改变了字符串 <code>s</code> 的长度，那么每次都需要重新计算。如果移出去的话，就会导致问题。</p>
<p>所以很多时候只能靠程序员自己进行代码优化。</p>
<h3 id="注意内存问题">注意内存问题</h3>
<p>接下来我们看另一段代码及其汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// 把 nxn 的矩阵 a 的每一行加起来，存到向量 b 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">sum_rows1</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的汇编代码为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp"># sum_rows1 的内循环
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">.</span><span class="nl">L4</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">movsd</span>   <span class="p">(</span><span class="o">%</span><span class="n">rsi</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="o">%</span><span class="n">xmm0</span>  <span class="err">#</span> <span class="err">浮点数载入</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addsd</span>   <span class="p">(</span><span class="o">%</span><span class="n">rdi</span><span class="p">),</span> <span class="o">%</span><span class="n">xmm0</span>           <span class="err">#</span> <span class="err">浮点数加</span>
</span></span><span class="line"><span class="cl">    <span class="n">movsd</span>   <span class="o">%</span><span class="n">xmm0</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="n">rsi</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>  <span class="err">#</span> <span class="err">浮点数保存</span>
</span></span><span class="line"><span class="cl">    <span class="n">addq</span>    <span class="err">$</span><span class="mi">8</span><span class="p">,</span> <span class="o">%</span><span class="n">rdi</span>
</span></span><span class="line"><span class="cl">    <span class="n">cmpq</span>    <span class="o">%</span><span class="n">rcx</span><span class="p">,</span> <span class="o">%</span><span class="n">rdi</span>
</span></span><span class="line"><span class="cl">    <span class="n">jne</span>     <span class="p">.</span><span class="n">L4</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到在汇编中，每次都会把 <code>b[i]</code> 存进去再读出来，为什么编译器会有这么奇怪的做法呢？因为有可能这里的 <code>a</code> 和 <code>b</code> 指向的是同一块内存地址，那么每次更新，都会使得值发生变化。但是中间过程是什么，实际上是没有必要存储起来的，所以我们引入一个临时变量，这样就可以消除内存引用的问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// 把 nxn 的矩阵 a 的每一行加起来，存到向量 b 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">sum_rows2</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">double</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">val</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的汇编代码为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># sum_rows2 内循环
</span></span><span class="line"><span class="cl">.L10:
</span></span><span class="line"><span class="cl">    addsd   (%rdi), %xmm0   # 浮点数载入 + 加法
</span></span><span class="line"><span class="cl">    addq    $9, %rdi
</span></span><span class="line"><span class="cl">    cmpq    %rax, %rdi
</span></span><span class="line"><span class="cl">    jne     .L10
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，加入了临时变量后，解决了奇怪的内存问题，生成的汇编代码干净了许多。</p>
<h3 id="处理条件分支">处理条件分支</h3>
<p>这个问题，如果不是对处理器执行指令的机制有一定了解的话，可能会难以理解。</p>
<p>现代处理器普遍采用超标量设计，也就是基于流水线来进行指令的处理，也就是说，当执行当前指令时，接下来要执行的几条指令已经进入流水线的处理流程了。</p>
<p>这个很重要，对于顺序执行来说，不会有任何问题，但是对于条件分支来说，在跳转指令时可能会改变程序的走向，也就是说，之前载入的指令可能是无效的。这个时候就只能清空流水线，然后重新进行载入。为了减少清空流水线所带来的性能损失，处理器内部会采用称为『分支预测』的技术。</p>
<p>比方说在一个循环中，根据预测，可能除了最后一次跳出循环的时候会判断错误之外，其他都是没有问题的。这就可以接受，但是如果处理器不停判断错误的话（比方说代码逻辑写得很奇怪），性能就会得到极大的拖累。</p>
<p>分支问题有些时候会成为最主要的影响性能的因素，但有的时候其实很难避免。</p>
<h2 id="5the-memory-hierarchycache-memories">5.The Memory Hierarchy&amp;Cache Memories</h2>
<p>The Memory Hierarchy see <a href="https://wdxtub.com/csapp/thin-csapp-3/2016/04/16/">【读薄 CSAPP】叁 内存与缓存 | 小土刀 3.0</a></p>
<h3 id="cache-memory">Cache Memory</h3>
<ul>
<li>
<p><strong>Cold (compulsory) miss</strong></p>
<ul>
<li>Cold misses occur because the cache is empty.</li>
</ul>
</li>
<li>
<p><strong>Conflict miss</strong></p>
<ul>
<li>
<p>Most caches limit blocks at level k+1 to a small subset (sometimes a singleton) of the block positions at level k.</p>
</li>
<li>
<p>E.g. Block i at level k+1 must be placed in block (i mod 4) at level k.</p>
</li>
<li>
<p>Conflict misses occur when the level k cache is large enough, but multiple data objects all map to the same level k block.</p>
</li>
<li>
<p>E.g. Referencing blocks 0, 8, 0, 8, 0, 8, &hellip; would miss every time.</p>
</li>
</ul>
</li>
<li>
<p><strong>Capacity miss</strong></p>
<ul>
<li>Occurs when the set of active cache blocks (working set) is larger than the cache.</li>
</ul>
</li>
</ul>
<p>高速缓存存储器(Cache Memory)是 CPU 缓存系统甚至是金字塔式存储体系中最有代表性的缓存机制，前面我们了解了许多概念，这一节我们具体来看看高速缓存存储器是如何工作的。</p>
<p>首先要知道的是，高速缓存存储器是由硬件自动管理的 SRAM 内存，CPU 会首先从这里找数据，其所处的位置如下（蓝色部分）：</p>
<p><img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14612615839808.jpg" alt="img"></p>
<p>然后我们需要关注高速缓冲存储器的三个关键组成部分（注意区分大小写）：</p>
<ul>
<li>S 表示集合(set)数量</li>
<li>E 表示数据行(line)的数量</li>
<li>B 表示每个缓存块(block)保存的字节数目</li>
</ul>
<p>在图上表示出来就是</p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14612628563878.jpg" alt="img" style="zoom:50%;" />
$$
C=S×E×BC=S×E×B
$$<p>
实际上可以理解为三种层级关系，对应不同的索引，这样分层的好处在于，通过层级关系简化搜索需要的时间，并且和字节的排布也是一一对应的（之后介绍缓存的时候就体现得更加明显）。</p>
<p>当处理器需要访问一个地址时，会先在高速缓冲存储器中进行查找，查找过程中我们首先在概念上把这个地址划分成三个部分：</p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14612633441722.jpg" alt="img" style="zoom:67%;" />
<h4 id="读取">读取</h4>
<p>具体在从缓存中读取一个地址时，首先我们通过 set index 确定要在哪个 set 中寻找，确定后利用 tag 和同一个 set 中的每个 line 进行比对，找到 tag 相同的那个 line，最后再根据 block offset 确定要从 line 的哪个位置读起（这里的而 line 和 block 是一个意思）。</p>
<p>当 E=1 时，也就是每个 set 只有 1 个 line 的时候，称之为直接映射缓存(Direct Mapped Cache)，如下图所示</p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/14612642281687.jpg" alt="img" style="zoom:50%;" />
<p>这种情况下，因为每个 set 对应 1 个 line，反过来看，1 个 line 就需要一个 set，所以 set index 的位数就会较多（和之后的多路映射对比）。具体的检索过程就是先通过 set index 确定哪个 set，然后看是否 valid，然后比较那个 set 里唯一 line 的 tag 和地址的 t bits 是否一致，就可以确定是否缓存命中。</p>
<p>命中之后根据 block offset 确定偏移量，因为需要读入一个 int，所以会读入 4 5 6 7 这四个字节（假设缓存是 8 个字节）。如果 tag 不匹配的话，这行会被扔掉并放新的数据进来。</p>
<p>然后我们来看一个具体的例子，假设我们的寻址空间是 M=16 字节，也就是 4 位的地址，对应 B=2, S=4, E=1，我们按照如下顺序进行数据读取：</p>
<ul>
<li><code>0 00 0</code>, miss</li>
<li><code>0 00 1</code>, hit</li>
<li><code>0 11 1</code>, miss</li>
<li><code>1 00 0</code>, miss</li>
<li><code>0 00 0</code>, miss</li>
</ul>
<p>缓存中的具体情况是，这里 x 表示没有任何内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">       v  Tag   Block
</span></span><span class="line"><span class="cl">Set 0  1   0    M[0-1]
</span></span><span class="line"><span class="cl">Set 1  x   x      x
</span></span><span class="line"><span class="cl">Set 2  x   x      x
</span></span><span class="line"><span class="cl">Set 3  1   0    M[6-7]
</span></span></code></pre></td></tr></table>
</div>
</div><p>缓存的大小如图所示，对应就是有 4 个 set，所以需要 2 位的 set index，所以进行读入的时候，会根据中间两位来确定在哪个 set 中查找，其中 8 和 0，因为中间两位相同，会产生冲突，导致连续 miss，这个问题可以用多路映射来解决。</p>
<p>当 E 大于 1 时，也就是每个 set 有 E 个 line 的时候，称之为 E 路联结缓存。这里每个 set 有两个 line，所以就没有那么多 set，也就是说 set index 可以少一位（集合数量少一倍）。</p>
<p>再简述一下整个过程，先从 set index 确定那个 set，然后看 valid 位，接着利用 t bits 分别和每个 line 的 tag 进行比较，如果匹配则命中，那么返回 4 5 位置的数据，如果不匹配，就需要替换，可以随机替换，也可以用 least recently used(LRU) 来进行替换。</p>
<p>我们再用刚才的例子来看看是否会增加命中率，这里假设我们的寻址空间是 M=16 字节，也就是 4 位的地址，对应 B=2, S=2, E=2，我们按照如下顺序进行数据读取：</p>
<ul>
<li><code>0 00 0</code>, miss</li>
<li><code>0 00 1</code>, hit</li>
<li><code>0 11 1</code>, miss</li>
<li><code>1 00 0</code>, miss</li>
<li><code>0 00 0</code>, hit</li>
</ul>
<p>缓存中的具体情况是，这里 x 表示没有任何内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">       v   Tag   Block
</span></span><span class="line"><span class="cl">Set 0  1   00    M[0-1]
</span></span><span class="line"><span class="cl">Set 0  1   10    M[8-9]
</span></span><span class="line"><span class="cl">Set 1  1   01    M[6-7]
</span></span><span class="line"><span class="cl">Set 1  0   x     x
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到因为每个 set 有 2 个 line，所以只有 2 个 set，set index 也只需要 1 位了，这个情况下即使 8 和 0 的 set index 一致，因为一个 set 可以容纳两个数据，所以最后一次访问 0，就不会 miss 了。</p>
<h4 id="写入">写入</h4>
<p>在整个存储层级中，不同的层级可能会存放同一个数据的不同拷贝（如 L1, L2, L3, 主内存, 硬盘）。如果发生写入命中的时候（也就是要写入的地址在缓存中有），有两种策略：</p>
<ul>
<li>Write-through: 命中后更新缓存，同时写入到内存中</li>
<li>Write-back: 直到这个缓存需要被置换出去，才写入到内存中（需要额外的 dirty bit 来表示缓存中的数据是否和内存中相同，因为可能在其他的时候内存中对应地址的数据已经更新，那么重复写入就会导致原有数据丢失）</li>
</ul>
<p>在写入 miss 的时候，同样有两种方式：</p>
<ul>
<li>Write-allocate: 载入到缓存中，并更新缓存（如果之后还需要对其操作，这个方式就比较好）</li>
<li>No-write-allocate: 直接写入到内存中，不载入到缓存</li>
</ul>
<p>这四种策略通常的搭配是：</p>
<ul>
<li>Write-through + No-write-allocate</li>
<li>Write-back + Write-allocate</li>
</ul>
<p>其中第一种可以保证绝对的数据一致性，第二种效率会比较高（通常情况下）。</p>
<h3 id="different-indexing">Different Indexing</h3>
<div>
    <img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250308110308611.png" alt="image-20250308110308611" style="zoom:25%;" />
    <img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250308110924669.png" alt="image-20250308110924669" style="zoom:21.5%;" />
</div>
<p>Due to spatial locality, most data in real-world programs is stored in contiguous memory regions (like arrays or buffers).</p>
<p>This means that when a program accesses memory sequentially, only the lower bits of the address (which indicate the offset within a block) change frequently, while the higher bits (which represent the larger memory block or region) remain constant until a larger step is taken.</p>
<p>So $TTSSBB$ is better than $SSTTBB$ because the former indexing changes its Set index more frequently, resulting to more seperate data and less frequent comflict miss.</p>
<h3 id="cache-lab">Cache lab</h3>
<ul>
<li>“I” denotes an instruction load, “L” a data load, “S” a data store, and “M” a data modify (i.e., a data load followed by a data store).
<ul>
<li>&rsquo;load&rsquo; stands for accessing the bits within a cache block—if they’re already in the cache, it just reads the relevant portion; if not, the entire block is loaded first before reading out the desired bits.</li>
</ul>
</li>
</ul>
<h2 id="6linking">6.Linking</h2>
<p>见<a href="https://wdxtub.com/csapp/thin-csapp-4/2016/04/16/">【读薄 CSAPP】肆 链接 | 小土刀 3.0</a></p>
<h2 id="7exceptional-control-flow异常流控制">7.<strong>Exceptional Control Flow</strong>(异常流控制)</h2>
<p><strong>Processors do only one thing:</strong></p>
<ul>
<li>
<p>From startup to shutdown, a CPU simply reads and executes (interprets) a sequence of instructions, one at a time</p>
</li>
<li>
<p>This sequence is the CPU’s <em>control flow</em> (or <em>flow of control</em>)</p>
</li>
</ul>
<p><strong>Up to now: two mechanisms for changing control flow:</strong></p>
<ul>
<li>
<p>Jumps and branches</p>
</li>
<li>
<p>Call and return</p>
</li>
</ul>
<p>React to changes in <strong>program</strong> <strong>state</strong></p>
<p>但是遇到异常的控制流时，就没办法应对了，所以需要异常流控制。</p>
<p>异常控制流存在于系统的每个层级，最底层的机制称为<strong>异常(Exception)</strong>，用以改变控制流以响应系统事件，通常是由硬件的操作系统共同实现的。更高层次的异常控制流包括<strong>进程切换(Process Context Switch)</strong>、<strong>信号(Signal)<strong>和</strong>非本地跳转(Nonlocal Jumps)</strong>，也可以看做是一个从硬件过渡到操作系统，再从操作系统过渡到语言库的过程。进程切换是由硬件计时器和操作系统共同实现的，而信号则只是操作系统层面的概念了，到了非本地跳转就已经是在 C 运行时库中实现的了。</p>
<h3 id="exceptions-and-processes"><strong>Exceptions and Processes</strong></h3>
<h4 id="异常-exception">异常 Exception</h4>
<p>这里的异常指的是把控制交给系统内核来响应某些事件（例如处理器状态的变化），其中内核是操作系统常驻内存的一部分，而这类事件包括除以零、数学运算溢出、页错误、I/O 请求完成或用户按下了 ctrl+c 等等系统级别的事件。</p>
<p>具体的过程可以用下图表示：</p>
<p><img src="https://wdxtub.com/images/csapp/14613541138958.jpg" alt="img"></p>
<p>系统会通过异常表(Exception Table)来确定跳转的位置，每种事件都有对应的唯一的异常编号，发生对应异常时就会调用对应的异常处理代码</p>
<h5 id="异步异常中断">异步异常（中断）</h5>
<p>异步异常(Asynchronous Exception)称之为中断(Interrupt)，是由处理器外面发生的事情引起的。对于执行程序来说，这种“中断”的发生完全是异步的，因为不知道什么时候会发生。CPU对其的响应也完全是被动的，但是可以屏蔽掉。这种情况下：</p>
<ul>
<li>需要设置处理器的中断指针(interrupt pin)</li>
<li>处理完成后会返回之前控制流中的『下一条』指令</li>
</ul>
<p>比较常见的中断有两种：</p>
<ul>
<li>计时器中断：计时器中断是由计时器芯片每隔几毫秒触发的，内核用计时器终端来从用户程序手上拿回控制权。</li>
<li>I/O 中断：I/O 中断类型比较多样，比方说键盘输入了 ctrl-c，网络中一个包接收完毕和硬盘中传输的文件包送达，都会触发这样的中断。</li>
</ul>
<h5 id="同步异常">同步异常</h5>
<p>同步异常(Synchronous Exception)是因为执行某条指令所导致的事件，分为陷阱(Trap)、故障(Fault)和终止(Abort)三种情况。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">类型</th>
          <th style="text-align: center">原因</th>
          <th style="text-align: center">行为</th>
          <th style="text-align: center">示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">陷阱</td>
          <td style="text-align: center">有意的异常</td>
          <td style="text-align: center">返回到下一条指令</td>
          <td style="text-align: center">系统调用，断点</td>
      </tr>
      <tr>
          <td style="text-align: center">故障</td>
          <td style="text-align: center">潜在可恢复的错误</td>
          <td style="text-align: center">返回到当前指令</td>
          <td style="text-align: center">页故障(page faults)</td>
      </tr>
      <tr>
          <td style="text-align: center">终止</td>
          <td style="text-align: center">不可恢复的错误</td>
          <td style="text-align: center">终止当前程序</td>
          <td style="text-align: center">非法指令</td>
      </tr>
  </tbody>
</table>
<p>这里需要注意三种不同类型的处理方式，比方说陷阱和中断一样，会返回执行『下一条』指令；而故障会重新执行之前触发事件的指令；终止则是直接退出当前的程序。</p>
<h5 id="system-calls">System Calls</h5>
<p>系统调用看起来像是函数调用，但其实是走异常控制流的，在 x86-64 系统中，每个系统调用都有一个唯一的 ID，如</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">编号</th>
          <th style="text-align: center">名称</th>
          <th style="text-align: center">描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">0</td>
          <td style="text-align: center"><code>read</code></td>
          <td style="text-align: center">读取文件</td>
      </tr>
      <tr>
          <td style="text-align: center">1</td>
          <td style="text-align: center"><code>write</code></td>
          <td style="text-align: center">写入文件</td>
      </tr>
      <tr>
          <td style="text-align: center">2</td>
          <td style="text-align: center"><code>open</code></td>
          <td style="text-align: center">打开文件</td>
      </tr>
      <tr>
          <td style="text-align: center">3</td>
          <td style="text-align: center"><code>close</code></td>
          <td style="text-align: center">关闭文件</td>
      </tr>
      <tr>
          <td style="text-align: center">4</td>
          <td style="text-align: center"><code>stat</code></td>
          <td style="text-align: center">获取文件信息</td>
      </tr>
      <tr>
          <td style="text-align: center">57</td>
          <td style="text-align: center"><code>fork</code></td>
          <td style="text-align: center">创建进程</td>
      </tr>
      <tr>
          <td style="text-align: center">59</td>
          <td style="text-align: center"><code>execve</code></td>
          <td style="text-align: center">执行一个程序</td>
      </tr>
      <tr>
          <td style="text-align: center">60</td>
          <td style="text-align: center"><code>_exit</code></td>
          <td style="text-align: center">关闭进程</td>
      </tr>
      <tr>
          <td style="text-align: center">62</td>
          <td style="text-align: center"><code>kill</code></td>
          <td style="text-align: center">向进程发送信号</td>
      </tr>
  </tbody>
</table>
<p>举个例子，假设用户调用了 <code>open(filename, options)</code>，系统实际上会执行 <code>__open</code> 函数，也就是进行系统调用 <code>syscall</code>，如果返回值是负数，则是出错，汇编代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">00000000000e5d70 &lt;__open&gt;:
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    e5d79: b8 02 00 00 00     mov $0x2, %eax    # open 是编号 2 的系统调用
</span></span><span class="line"><span class="cl">    e5d7e: 0f 05              syscall           # 调用的返回值会在 %rax 中
</span></span><span class="line"><span class="cl">    e5d80: 48 3d 01 f0 ff ff  cmp $0xfffffffffffff001, %rax
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    e5dfa: c3                 retq
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的示意图是：</p>
<img src="https://wdxtub.com/images/csapp/14613688255926.jpg" alt="img" style="zoom:33%;" />
<ul>
<li><code>%rax</code> contains syscall number</li>
<li>Other arguments in <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%r10</code>, <code>%r8</code>, <code>%r9</code></li>
<li>Return value in <code>%rax</code></li>
<li>Negative value is an error corresponding to negative <code>errno</code></li>
</ul>
<p>这里我们以 Page Fault 为例，来说明 Fault 的机制。Page Fault 发生的条件是：</p>
<ul>
<li>用户写入内存位置</li>
<li>但该位置目前还不在内存中</li>
</ul>
<p>比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">[</span><span class="mi">500</span><span class="p">]</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么系统会通过 Page Fault 把对应的部分载入到内存中，然后重新执行赋值语句：</p>
<img src="https://wdxtub.com/images/csapp/14613689402121.jpg" alt="img" style="zoom:33%;" />
<p>但是如果代码改为这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">[</span><span class="mi">5000</span><span class="p">]</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>也就是引用非法地址的时候，整个流程就会变成：</p>
<img src="https://wdxtub.com/images/csapp/14613690660319.jpg" alt="img" style="zoom:33%;" />
<p>具体来说会像用户进程发送 <code>SIGSEGV</code> 信号，用户进程会以 segmentation fault 的标记退出。</p>
<p>从上面我们就可以看到异常的具体实现是依靠在用户代码和内核代码间切换而实现的，是非常底层的机制。</p>
<h4 id="进程">进程</h4>
<p>进程(Processes)是计算机科学中最为重要的思想之一，进程才是程序（指令和数据）的真正运行实例。之所以重要，是因为进程给每个应用提供了两个非常关键的抽象：</p>
<ul>
<li>
<p>逻辑控制流</p>
<ul>
<li>
<p>Each program seems to have exclusive use of the CPU</p>
</li>
<li>
<p>Provided by kernel mechanism called <em>context switching</em></p>
</li>
</ul>
</li>
<li>
<p>私有地址空间</p>
</li>
</ul>
<p>逻辑控制流通过称为上下文切换(context switching)的内核机制让每个程序都感觉自己在独占处理器。私有地址空间则是通过称为虚拟内存(virtual memory)的机制让每个程序都感觉自己在独占内存。这样的抽象使得具体的进程不需要操心处理器和内存的相关适宜，也保证了在不同情况下运行同样的程序能得到相同的结果。</p>
<p>计算机会同时运行多个进程，有前台应用，也后台任务，我们在 Mac 的终端下输入 <code>top</code>（或者更酷炫的 <code>htop</code>），就可以看到如下的进程信息</p>
<img src="https://wdxtub.com/images/csapp/14613699267859.jpg" alt="img" style="zoom:50%;" />
<h5 id="进程切换-process-context-switch">进程切换 Process Context Switch</h5>
<p>这么多进程，具体是如何工作的呢？我们来看看下面的示意图：</p>
<img src="https://wdxtub.com/images/csapp/14613707308133.jpg" alt="img" style="zoom: 67%;" />
<p>左边是单进程的模型，内存中保存着进程所需的各种信息，因为该进程独占 CPU，所以并不需要保存寄存器值。而在右边的单核多进程模型中，虚线部分可以认为是当前正在执行的进程，因为我们可能会切换到其他进程，所以内存中需要另一块区域来保存当前的寄存器值，以便下次执行的时候进行恢复（也就是所谓的上下文切换）。整个过程中，CPU 交替执行不同的进程，虚拟内存系统会负责管理地址空间，而没有执行的进程的寄存器值会被保存在内存中。切换到另一个进程的时候，会载入已保存的对应于将要执行的进程的寄存器值。</p>
<p>而现代处理器一般有多个核心，所以可以真正同时执行多个进程。这些进程会共享主存以及一部分缓存，具体的调度是由内核控制的，示意图如下：</p>
<img src="https://wdxtub.com/images/csapp/14613708880333.jpg" alt="img" style="zoom:67%;" />
<p>切换进程时，内核(kernel)会负责具体的调度，如下图所示</p>
<img src="https://wdxtub.com/images/csapp/14613717282590.jpg" alt="img" style="zoom:50%;" />
<h5 id="进程控制-process-control">进程控制 Process Control</h5>
<p><strong>系统调用的错误处理</strong></p>
<p>在遇到错误的时候，Linux 系统级函数通常会返回 -1 并且设置 <code>errno</code> 这个全局变量来表示错误的原因。使用的时候记住两个规则：</p>
<ol>
<li>对于每个系统调用都应该检查返回值</li>
<li>当然有一些系统调用的返回值为 void，在这里就不适用</li>
</ol>
<p>例如，对于 <code>fork()</code> 函数，我们应该这么写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if ((pid = fork()) &lt; 0) {
</span></span><span class="line"><span class="cl">    fprintf(stderr, &#34;fork error: %s\n&#34;, strerror(errno));
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果觉得这样写太麻烦，可以利用一个辅助函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void unix_error(char *msg) /* Unix-style error */
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    fprintf(stderr, &#34;%s: %s\n&#34;, msg, strerror(errno));
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 上面的片段可以写为
</span></span><span class="line"><span class="cl">if ((pid = fork()) &lt; 0)
</span></span><span class="line"><span class="cl">    unix_error(&#34;fork error&#34;);
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们甚至可以更进一步，把整个 <code>fork()</code> 包装起来，就可以自带错误处理，比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pid_t Fork(void)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">    if ((pid = fork()) &lt; 0)
</span></span><span class="line"><span class="cl">        unix_error(&#34;Fork error&#34;);
</span></span><span class="line"><span class="cl">    return pid;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用的时候直接使用 <code>pid = Fork();</code> 即可（注意这里是大写的 F）</p>
<p><strong>获取进程信息</strong></p>
<p>我们可以用下面两个函数获取进程的相关信息：</p>
<ul>
<li><code>pid_t getpid(void)</code> - 返回当前进程的 PID</li>
<li><code>pid_t getppid(void)</code> - 返回当前进程的父进程的 PID</li>
</ul>
<p>我们可以认为，进程有三个主要状态：</p>
<ul>
<li>运行 Running
<ul>
<li>正在被执行、正在等待执行或者最终将会被执行</li>
</ul>
</li>
<li>停止 Stopped
<ul>
<li>执行被挂起，在进一步通知前不会计划执行</li>
</ul>
</li>
<li>终止 Terminated
<ul>
<li>进程被永久停止</li>
</ul>
</li>
</ul>
<p>另外的两个状态称为新建(new)和就绪(ready)，这里不再赘述。</p>
<p><strong>终止进程</strong></p>
<p>在下面三种情况时，进程会被终止：</p>
<ol>
<li>接收到一个终止信号</li>
<li>返回到 <code>main</code></li>
<li>调用了 <code>exit</code> 函数</li>
</ol>
<p><code>exit</code> 函数会被调用一次，但从不返回，具体的函数原型是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 以 status 状态终止进程，0 表示正常结束，非零则是出现了错误
</span></span><span class="line"><span class="cl">void exit(int status)
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>创建进程</strong></p>
<p>调用 <code>fork</code> 来创造新进程。这个函数很有趣，执行一次，但是会返回两次，具体的函数原型为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 对于子进程，返回 0
</span></span><span class="line"><span class="cl">// 对于父进程，返回子进程的 PID
</span></span><span class="line"><span class="cl">int fork(void)
</span></span></code></pre></td></tr></table>
</div>
</div><p>子进程几乎和父进程一模一样，</p>
<ul>
<li>有相同且独立的虚拟地址空间，</li>
<li>有父进程已经打开的文件描述符(file descriptor)</li>
<li>有不同的进程 PID</li>
</ul>
<p>看一个简单的例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">    int x = 1;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    pid = Fork();
</span></span><span class="line"><span class="cl">    if (pid == 0) 
</span></span><span class="line"><span class="cl">    {   // Child
</span></span><span class="line"><span class="cl">        printf(&#34;I&#39;m the child!  x = %d\n&#34;, ++x);
</span></span><span class="line"><span class="cl">        exit(0);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    // Parent
</span></span><span class="line"><span class="cl">    printf(&#34;I&#39;m the parent! x = %d\n&#34;, --x);
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">linux&gt; ./forkdemo
</span></span><span class="line"><span class="cl">I&#39;m the parent! x = 0
</span></span><span class="line"><span class="cl">I&#39;m the child!  x = 2
</span></span></code></pre></td></tr></table>
</div>
</div><p>有以下几点需要注意：</p>
<ul>
<li>调用一次，但是会有两个返回值</li>
<li>并行执行，不能预计父进程和子进程的执行顺序</li>
<li>拥有自己独立的地址空间（也就是变量都是独立的），除此之外其他都相同</li>
<li>在父进程和子进程中 <code>stdout</code> 是一样的（都会发送到标准输出）</li>
</ul>
<h5 id="进程图">进程图</h5>
<p>进程图是一个很好的帮助我们理解进程执行的工具：</p>
<ul>
<li>每个节点代表一条执行的语句</li>
<li>a -&gt; b 表示 a 在 b 前面执行</li>
<li>边可以用当前变量的值来标记</li>
<li><code>printf</code> 节点可以用输出来进行标记</li>
<li>每个图由一个入度为 0 的节点作为起始</li>
</ul>
<p>对于进程图来说，只要满足拓扑排序，就是可能的输出。我们还是用刚才的例子来简单示意一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">    int x = 1;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    pid = Fork();
</span></span><span class="line"><span class="cl">    if (pid == 0) 
</span></span><span class="line"><span class="cl">    {   // Child
</span></span><span class="line"><span class="cl">        printf(&#34;child! x = %d\n&#34;, --x);
</span></span><span class="line"><span class="cl">        exit(0);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    // Parent
</span></span><span class="line"><span class="cl">    printf(&#34;parent! x = %d\n&#34;, x);
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的进程图为</p>
<img src="https://wdxtub.com/images/csapp/14625029984869.jpg" alt="img" style="zoom:33%;" />
<h5 id="回收子进程">回收子进程</h5>
<p>即使主进程已经终止，子进程也还在消耗系统资源，我们称之为『僵尸』。为了『打僵尸』，就可以采用『收割』(Reaping) 的方法。父进程利用 <code>wait</code> 或 <code>waitpid</code> 回收已终止的子进程，然后给系统提供相关信息，kernel 就会把 zombie child process 给删除。</p>
<p>如果父进程不回收子进程的话，通常来说会被 <code>init</code> 进程(pid == 1)回收，所以一般不必显式回收。但是在长期运行的进程中，就需要显式回收（例如 shell 和 server）。</p>
<p>如果想在子进程载入其他的程序，就需要使用 <code>execve</code> 函数，具体可以查看对应的 man page，这里不再深入。</p>
<p><strong>Parent reaps a child by calling the</strong> <strong>wait</strong> <strong>function</strong></p>
<ul>
<li>int wait(int child_status)
<ul>
<li>Suspends current process until one of its children terminates</li>
<li>Return value is the <strong>pid</strong> of the child process that terminated</li>
<li>If <strong>child_status</strong> <strong>!= NULL</strong>, then the integer it points to will be set to a value that indicates reason the child terminated and the exit status.</li>
</ul>
</li>
</ul>
<p>waitpid: Waiting for a Specific Process</p>
<ul>
<li>pid_t waitpid(pid_t pid, int &amp; status, int option)
<ul>
<li>Suspends current process until specific process terminates. Various options (see textbook)</li>
</ul>
</li>
</ul>
<p>execve: Loading and Running Programs</p>
<ul>
<li>int execve(char *filename, char *argv[], char *envp[])
<ul>
<li><strong>Loads</strong> <strong>and</strong> <strong>runs in the current process:</strong>
<ul>
<li>Executable file <strong>filename</strong>. Can be object file or script file beginning with #!interpreter     (e.g., #!/bin/bash)</li>
</ul>
</li>
<li>…with argument list <strong>argv</strong>
<ul>
<li>By convention <strong>argv</strong>**[0]==filename**</li>
</ul>
</li>
<li>…and environment variable list <strong>envp</strong>
<ul>
<li><strong>name=value”</strong> <strong>strings (e.g.,</strong> <strong>USER=droh</strong>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Structure of the stack when a new program starts</strong></p>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250316101455527.png" alt="image-20250316101455527" style="zoom:33%;" />
<h3 id="信号-signal">信号 Signal</h3>
<p>Linux 的进程树，可以通过 <code>pstree</code> 命令查看，如下图所示：</p>
<img src="https://wdxtub.com/images/csapp/14613761276198.jpg" alt="img" style="zoom:33%;" />
<p>对于前台进程来说，我们可以在其执行完成后进行回收，而对于后台进程来说，因为不能确定具体执行完成的时间，所以终止之后就成为了僵尸进程，无法被回收并因此造成内存泄露。</p>
<p>这怎么办呢？同样可以利用异常控制流，当后台进程完成时，内核会中断常规执行并通知我们，具体的通知机制就是『信号』(signal)。</p>
<ul>
<li>Akin to exceptions and interrupts</li>
<li>Sent from the kernel (sometimes at the request of another process) to a process</li>
<li>Signal type is identified by small integer ID’s (1-30)</li>
<li>Only information in a signal is its ID and the fact that it arrived</li>
</ul>
<p>信号是 Unix、类 Unix 以及其他 POSIX 兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。</p>
<p>这样看来，信号其实是类似于异常和中断的，是由内核（在其他进程的请求下）向当前进程发出的。信号的类型由 1-30 的整数定义，信号所能携带的信息极少，一是对应的编号，二就是信号到达这个事实。下面是几个比较常用的信号的编号及简介：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">编号</th>
          <th style="text-align: center">名称</th>
          <th style="text-align: center">默认动作</th>
          <th style="text-align: center">对应事件</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">2</td>
          <td style="text-align: center">SIGINT</td>
          <td style="text-align: center">终止</td>
          <td style="text-align: center">用户输入 ctrl+c</td>
      </tr>
      <tr>
          <td style="text-align: center">9</td>
          <td style="text-align: center">SIGKILL</td>
          <td style="text-align: center">终止</td>
          <td style="text-align: center">终止程序（不能重写或忽略）</td>
      </tr>
      <tr>
          <td style="text-align: center">11</td>
          <td style="text-align: center">SIGSEGV</td>
          <td style="text-align: center">终止且 Dump</td>
          <td style="text-align: center">段冲突 Segmentation violation</td>
      </tr>
      <tr>
          <td style="text-align: center">14</td>
          <td style="text-align: center">SIGALRM</td>
          <td style="text-align: center">终止</td>
          <td style="text-align: center">时间信号</td>
      </tr>
      <tr>
          <td style="text-align: center">17</td>
          <td style="text-align: center">SIGCHLD</td>
          <td style="text-align: center">忽略</td>
          <td style="text-align: center">子进程停止或终止</td>
      </tr>
  </tbody>
</table>
<p>内核通过给目标进程发送信号，来更新目标进程的状态，具体的场景为：</p>
<ul>
<li>内核检测到了如除以零(SIGFPE)或子进程终止(SIGCHLD)的系统事件</li>
<li>另一个进程调用了 <code>kill</code> 指令来请求内核发送信号给指定的进程</li>
</ul>
<p>目标进程接收到信号后，内核会强制要求进程对于信号做出响应，可以有几种不同的操作：</p>
<ul>
<li><strong>忽略</strong>这个型号</li>
<li><strong>终止</strong>进程</li>
<li><strong>捕获</strong>信号，执行信号处理器(signal handler)，类似于异步中断中的异常处理器(exception handler)</li>
</ul>
<p>具体的过程如下：</p>
<img src="https://wdxtub.com/images/csapp/14614121439266.jpg" alt="img" style="zoom: 50%;" />
<p>如果信号已被发送但是未被接收，那么处于等待状态(pending)，同类型的信号至多只会有一个待处理信号(pending signal)，一定要注意这个特性，因为内部实现机制不可能提供较复杂的数据结构，所以信号的接收并不是一个队列。比如说进程有一个 <code>SIGCHLD</code> 信号处于等待状态，那么之后进来的 <code>SIGCHLD</code> 信号都会被直接扔掉。</p>
<p>当然，进程也可以阻塞特定信号的接收，但信号的发送并不受控制，所以被阻塞的信号仍然可以被发送，不过直到进程取消阻塞该信号之后才会被接收。内核用等待(pending)位向量和阻塞(blocked)位向量来维护每个进程的信号相关状态。</p>
<h4 id="进程组">进程组</h4>
<img src="https://typora-1344509263.cos.ap-guangzhou.myqcloud.com/test/image-20250316102843274.png" alt="image-20250316102843274" style="zoom:33%;" />
<p><strong>Every process belongs to exactly one process group</strong>.每个进程都只属于一个进程组，从前面的进程树状图中我们也能大概了解一二，想要了解相关信息，一般使用如下函数：</p>
<ul>
<li><code>getpgrp()</code> - 返回当前进程的进程组</li>
<li><code>setpgid()</code> - 设置一个进程的进程组</li>
</ul>
<p>我们可以据此指定一个进程组或者一个单独的进程，比方说可以通过 <code>kill</code> 应用来发送信号，流入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 创建子进程
</span></span><span class="line"><span class="cl">linux&gt; ./forks 16
</span></span><span class="line"><span class="cl">Child1: pid=24818 pgrp=24817
</span></span><span class="line"><span class="cl">Child2: pid=24819 pgrp=24817
</span></span><span class="line"><span class="cl"># 查看进程
</span></span><span class="line"><span class="cl">linux&gt; ps
</span></span><span class="line"><span class="cl">  PID TTY      TIME  CMD
</span></span><span class="line"><span class="cl">24788 pts/2 00:00:00 tcsh
</span></span><span class="line"><span class="cl">24818 pts/2 00:00:02 forks
</span></span><span class="line"><span class="cl">24819 pts/2 00:00:02 forks
</span></span><span class="line"><span class="cl">24820 pts/2 00:00:00 ps
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 可以选择关闭某个进程
</span></span><span class="line"><span class="cl">linux&gt; /bin/kill -9 24818
</span></span><span class="line"><span class="cl"># 也可以关闭某个进程组，会关闭该组中所有进程
</span></span><span class="line"><span class="cl">linux&gt; /bin/kill -9 -24817
</span></span><span class="line"><span class="cl"># 查看进程
</span></span><span class="line"><span class="cl">linux&gt; ps
</span></span><span class="line"><span class="cl">  PID TTY      TIME  CMD
</span></span><span class="line"><span class="cl">24788 pts/2 00:00:00 tcsh
</span></span><span class="line"><span class="cl">24820 pts/2 00:00:00 ps
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里可以看到，第一个命令只会杀掉编号为 24818 的进程，但是第二个命令，因为有两个进程都属于进程组 24817，所以会杀掉进程组中的每个进程。</p>
<p>我们也可以通过键盘让内核向每个前台进程发送 SIGINT(SIGTSTP) 信号</p>
<ul>
<li>SIGINT - <code>ctrl+c</code> 默认终止进程</li>
<li>SIGTSTP - <code>ctrl+z</code> 默认挂起进程</li>
</ul>
<p>下面是一个简单的例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">linux&gt; ./forks 17
</span></span><span class="line"><span class="cl">Child: pid=28108 pgrp=28107
</span></span><span class="line"><span class="cl">Parent: pid=28107 pgrp=28107
</span></span><span class="line"><span class="cl"># 按下 ctrl+z
</span></span><span class="line"><span class="cl">Suspended # 进程被挂起
</span></span><span class="line"><span class="cl">linux&gt; ps w
</span></span><span class="line"><span class="cl">  PID TTY   STAT  TIME  COMMAND
</span></span><span class="line"><span class="cl">27699 pts/8 Ss    00:00 -tcsh
</span></span><span class="line"><span class="cl">28107 pts/8 T     00:02 ./forks 17
</span></span><span class="line"><span class="cl">28108 pts/8 T     00:02 ./forks 17
</span></span><span class="line"><span class="cl">28109 pts/8 R+    00:00 ps w
</span></span><span class="line"><span class="cl">linux&gt; fg
</span></span><span class="line"><span class="cl">./forks 17
</span></span><span class="line"><span class="cl"># 按下 ctrl+c，进程被终止
</span></span><span class="line"><span class="cl">linux&gt; ps w
</span></span><span class="line"><span class="cl">  PID TTY   STAT  TIME  COMMAND
</span></span><span class="line"><span class="cl">27699 pts/8 Ss    00:00 -tcsh
</span></span><span class="line"><span class="cl">28109 pts/8 R+    00:00 ps w
</span></span></code></pre></td></tr></table>
</div>
</div><p>STAT 部分的第一个字母的意思</p>
<ul>
<li>S: 睡眠 sleeping</li>
<li>T: 停止 stopped</li>
<li>R: 运行 running</li>
</ul>
<p>第二个字母的意思：</p>
<ul>
<li>s: 会话管理者 session leader</li>
<li>+: 前台进程组</li>
</ul>
<p>更多信息可以查看 <code>man ps</code></p>
<p>如果想要发送信号，可以使用 <code>kill</code> 函数，下面是一个简单的示例，父进程通过发送 <code>SIGINT</code> 信号来终止正在无限循环的子进程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void forkandkill()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    pid_t pid[N];
</span></span><span class="line"><span class="cl">    int i;
</span></span><span class="line"><span class="cl">    int child_status;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    for (i = 0; i &lt; N; i++)
</span></span><span class="line"><span class="cl">        if ((pid[i] = fork()) == 0)
</span></span><span class="line"><span class="cl">            while(1) ;  // 死循环
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    for (i = 0; i &lt; N; i++)
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        printf(&#34;Killing process %d\n&#34;, pid[i]);
</span></span><span class="line"><span class="cl">        kill(pid[i], SIGINT);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    for (i = 0; i &lt; N; i++)
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        pid_t wpid = wait(&amp;child_status);
</span></span><span class="line"><span class="cl">        if (WIFEXITED(child_status))
</span></span><span class="line"><span class="cl">            printf(&#34;Child %d terminated with exit status %d\n&#34;,
</span></span><span class="line"><span class="cl">                    wpid, WEXITSTATUS(child_status));
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            printf(&#34;Child %d terminated abnormally\n&#34;, wpid);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="接收信号">接收信号</h4>
<p>所有的上下文切换都是通过调用某个异常处理器(exception handler)完成的，内核会计算对易于某个进程 p 的 pnb 值：<code>pnb = pending &amp; ~blocked</code></p>
<ul>
<li>
<p>如果 <code>pnb == 0</code>，那么就把控制交给进程 p 的逻辑流中的下一条指令</p>
</li>
<li>
<p>如果</p>
<p>​</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pnb != 0
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>选择 <code>pnb</code> 中最小的非零位 k，并强制进程 p 接收信号 k</li>
<li>接收到信号之后，进程 p 会执行对应的动作</li>
<li>对 <code>pnb</code> 中所有的非零位进行这个操作</li>
<li>最后把控制交给进程 p 的逻辑流中的下一条指令</li>
</ul>
</li>
</ul>
<p>每个信号类型都有一个预定义的『默认动作』，可能是以下的情况：</p>
<ul>
<li>终止进程</li>
<li>终止进程并 dump core</li>
<li>停止进程，收到 <code>SIGCONT</code> 信号之后重启</li>
<li>忽略信号</li>
</ul>
<p><code>signal</code> 函数可以修改默认的动作，函数原型为 <code>handler_t *signal(int signum, handler_t *handler)</code>。我们通过一个简单的例子来感受下，这里我们屏蔽了 <code>SIGINT</code> 函数，即使按下 <code>ctrl+c</code> 也不会终止</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">void</span> <span class="n">sigint_handler</span><span class="p">(</span><span class="ne">int</span> <span class="n">sig</span><span class="p">)</span> <span class="o">//</span> <span class="n">SIGINT</span> <span class="err">处理器</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s2">&#34;So you think you can stop the bomb with ctrl-c, do you?</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s2">&#34;Well...&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s2">&#34;OK. :-)</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">设定</span> <span class="n">SIGINT</span> <span class="err">处理器</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sigint_handler</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">unix_error</span><span class="p">(</span><span class="s2">&#34;signal error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">等待接收信号</span>
</span></span><span class="line"><span class="cl">    <span class="n">pause</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>信号处理器的工作流程可以认为是和当前用户进程『并发』的同一个『伪』进程，示意如下：</p>
<p>注：并行与并发的区别</p>
<p>计算机虽然只有一个 CPU，但操作系统能够将程序的执行单位细化，然后分开执行，从而实现伪并行执行。这种伪并行执行称为并发(concurrent)。使用多个 CPU 真的同时执行称为并行(parallel)</p>
<img src="https://wdxtub.com/images/csapp/14614181710603.jpg" alt="img" style="zoom: 50%;" />
<p>还有一个需要注意的是，信号处理器也可以被其他的信号处理器中断，控制流如下图所示：</p>
<img src="https://wdxtub.com/images/csapp/14614185201475.jpg" alt="img" style="zoom:50%;" />
<h4 id="阻塞信号">阻塞信号</h4>
<p>我们知道，内核会阻塞与当前在处理的信号同类型的其他正待等待的信号，也就是说，一个 SIGINT 信号处理器是不能被另一个 SIGINT 信号中断的。</p>
<p>如果想要显式阻塞，就需要使用 <code>sigprocmask</code> 函数了，以及其他一些辅助函数：</p>
<ul>
<li><code>sigemptyset</code> - 创建空集</li>
<li><code>sigfillset</code> - 把所有的信号都添加到集合中（因为信号数目不多）</li>
<li><code>sigaddset</code> - 添加指定信号到集合中</li>
<li><code>sigdelset</code> - 删除集合中的指定信号</li>
</ul>
<p>我们可以用下面这段代码来临时阻塞特定的信号：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sigset_t mask, prev_mask;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Sigemptyset(&amp;mask); // 创建空集
</span></span><span class="line"><span class="cl">Sigaddset(&amp;mask, SIGINT); // 把 SIGINT 信号加入屏蔽列表中
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 阻塞对应信号，并保存之前的集合作为备份
</span></span><span class="line"><span class="cl">Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">... // 这部分代码不会被 SIGINT 中断
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">// 取消阻塞信号，恢复原来的状态
</span></span><span class="line"><span class="cl">Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL);
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="安全处理信号">安全处理信号</h4>
<p>信号处理器的设计并不简单，因为它们和主程序并行且共享相同的全局数据结构，尤其要注意因为并行访问可能导致的数据损坏的问题，这里提供一些基本的指南（后面的课程会详细介绍）</p>
<ul>
<li>规则 1：信号处理器越简单越好
<ul>
<li>例如：设置一个全局的标记，并返回</li>
</ul>
</li>
<li>规则 2：信号处理器中只调用异步且信号安全(async-signal-safe)的函数
<ul>
<li>诸如 <code>printf</code>, <code>sprintf</code>, <code>malloc</code> 和 <code>exit</code> 都是不安全的！</li>
</ul>
</li>
<li>规则 3：在进入和退出的时候保存和恢复<code>errno</code>
<ul>
<li>这样信号处理器就不会覆盖原有的 <code>errno</code> 值</li>
</ul>
</li>
<li>规则 4：临时阻塞所有的信号以保证对于共享数据结构的访问
<ul>
<li>防止可能出现的数据损坏</li>
</ul>
</li>
<li>规则 5：用<code>volatile</code>关键字声明全局变量
<ul>
<li>这样编译器就不会把它们保存在寄存器中，保证一致性</li>
</ul>
</li>
<li>规则 6：用<code>volatile sig_atomic_t</code>来声明全局标识符(flag)
<ul>
<li>这样可以防止出现访问异常</li>
</ul>
</li>
</ul>
<p>这里提到的异步信号安全(async-signal-safety)指的是如下两类函数：</p>
<ol>
<li>所有的变量都保存在栈帧中的函数</li>
<li>不会被信号中断的函数</li>
<li>异步且信号安全意为不会因为接受信号而导致数据类型损坏，死锁，内部状态损坏和崩坏。</li>
</ol>
<p>Posix 标准指定了 117 个异步信号安全(async-signal-safe)的函数（可以通过 <code>man 7 signal</code> 查看）</p>
<img src="https://wdxtub.com/images/csapp/14614222627451.jpg" alt="img" style="zoom: 50%;" />
<h4 id="非本地跳转-non-local-jump">非本地跳转 Non local Jump</h4>
<p>所谓的本地跳转，指的是在一个程序中通过 goto 语句进行流程跳转，尽管不推荐使用goto语句，但在嵌入式系统中为了提高程序的效率，goto语句还是可以使用的。本地跳转的限制在于，我们不能从一个函数跳转到另一个函数中。如果想突破函数的限制，就要使用 <code>setjmp</code> 或 <code>longjmp</code> 来进行非本地跳转了。</p>
<ul>
<li>
<p>int setjmp(jmp_buf j)</p>
<ul>
<li>
<p>Must be called before longjmp</p>
</li>
<li>
<p>Identifies a return site for a subsequent longjmp</p>
</li>
<li>
<p>Called <strong>once</strong>, returns <strong>one or more</strong> times</p>
</li>
</ul>
</li>
<li>
<p>void longjmp(jmp_buf j, int i)</p>
<ul>
<li>
<p>Meaning:</p>
<ul>
<li>
<p>return from the <strong>setjmp</strong> remembered by jump buffer <strong>j</strong> again &hellip;</p>
</li>
<li>
<p>… this time returning <strong>i</strong> instead of 0</p>
</li>
</ul>
</li>
<li>
<p>Called after <strong>setjmp</strong></p>
</li>
<li>
<p>Called <strong>once</strong>, but <strong>never</strong> returns</p>
</li>
</ul>
</li>
</ul>
<p><code>setjmp</code> 保存当前程序的堆栈上下文环境(stack context)，见[进程图](# 进程图)，注意，这个保存的堆栈上下文环境仅在调用 <code>setjmp</code> 的函数内有效，如果调用 <code>setjmp</code> 的函数返回了，这个保存的堆栈上下文环境就失效了。调用 <code>setjmp</code> 的直接返回值为 0。</p>
<p><code>longjmp</code> 将会恢复由 <code>setjmp</code> 保存的程序堆栈上下文，即程序从调用 <code>setjmp</code> 处重新开始执行，不过此时的 <code>setjmp</code> 的返回值将是由 <code>longjmp</code> 指定的值。注意<code>longjmp</code> 不能指定0为返回值，即使指定了 0，<code>longjmp</code> 也会使 <code>setjmp</code> 返回 1。</p>
<p>我们可以利用这种方式，来跳转到其他的栈帧中，比方说在嵌套函数中，我们可以利用这个快速返回栈底的函数，我们来看如下代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">jmp_buf env;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">P1()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    if (setjmp(env))
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        // 跳转到这里
</span></span><span class="line"><span class="cl">    } else 
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        P2();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">P2()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    P2();
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    P3();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">P3()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    longjmp(env, 1);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的跳转过程为：</p>
<img src="https://wdxtub.com/images/csapp/14614229485048.jpg" alt="img" style="zoom:33%;" />
<p>也就是说，我们直接从 P3 跳转回了 P1，但是也有限制，函数必须在栈中（也就是还没完成）才可以进行跳转，下面的例子中，因为 P2 已经返回，所以不能跳转了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">jmp_buf env;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">P1()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    P2(); P3();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">P2()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    if (setjmp(env))
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        // 跳转到这里
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">P3()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    longjmp(env, 1);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为 P2 在跳转的时候已经返回，对应的栈帧在内存中已经被清理，所以 P3 中的 <code>longjmp</code> 并不能实现期望的操作。</p>
<h2 id="8virtual-memory">8.Virtual Memory</h2>
<h3 id="从物理内存到虚拟内存">从物理内存到虚拟内存</h3>
<p>物理地址一般应用在简单的嵌入式微控制器中（汽车、电梯、电子相框等），因为应用的范围有严格的限制，不需要在内存管理中引入过多的复杂度。</p>
<p>物理内存对于愈来愈快的cpu越来越容易空间不足。虚拟内存可以提供对每个进程独立的地址</p>
<p>但是对于计算机（以及其他智能设备）来说，虚拟地址则是必不可少的，通过 MMU(Memory management unit)把虚拟地址(Virtual Address, VA)转换为物理地址(Physical Address, PA)，再由此进行实际的数据传输。大致的过程如下图所示</p>
<p><img src="https://wdxtub.com/images/csapp/14615011037796.jpg" alt="img"></p>
<p>使用虚拟内存主要是基于下面三个考虑：</p>
<ol>
<li>可以更有效率的使用内存：使用 DRAM 当做部分的虚拟地址空间的缓存</li>
<li>简化内存管理：每个进程都有统一的线性地址空间</li>
<li>隔离地址控件：进程之间不会相互影响；用户程序不能访问内核信息和代码</li>
</ol>
<h3 id="虚拟内存的三个角色">虚拟内存的三个角色</h3>
<h4 id="作为缓存工具">作为缓存工具</h4>
<p>概念上来说，虚拟内存就是存储在磁盘上的 N 个连续字节的数组。这个数组的部分内容，会缓存在 DRAM 中，在 DRAM 中的每个缓存块(cache block)就称为页(page)，如下图所示：</p>
<img src="https://wdxtub.com/images/csapp/14615017442915.jpg" alt="img" style="zoom:50%;" />
<p>大致的思路和之前的 cache memory 是类似的，就是利用 DRAM 比较快的特性，把最常用的数据换缓存起来。如果要访问磁盘的话，大约会比访问 DRAM 慢一万倍，所以我们的目标就是尽可能从 DRAM 中拿数据。为此，我们需要：</p>
<ul>
<li>更大的页尺寸(page size)：通常是 4KB，有的时候可以达到 4MB</li>
<li>全相联(Fully associative)：每一个虚拟页(virual page)可以放在任意的物理页(physical page)中，没有限制。</li>
<li>映射函数非常复杂，所以没有办法用硬件实现，通常使用 Write-back 而非 Write-through 机制
<ul>
<li>Write-through: 命中后更新缓存，同时写入到内存中</li>
<li>Write-back: 直到这个缓存需要被置换出去，才写入到内存中（需要额外的 dirty bit 来表示缓存中的数据是否和内存中相同，因为可能在其他的时候内存中对应地址的数据已经更新，那么重复写入就会导致原有数据丢失）</li>
</ul>
</li>
</ul>
<p>具体怎么做呢？通过页表(page table)。每个页表实际上是一个数组，数组中的每个元素称为页表项(PTE, page table entry)，每个页表项负责把虚拟页映射到物理页上。在 DRAM 中，每个进程都有自己的页表，具体如下</p>
<img src="https://wdxtub.com/images/csapp/14615030555447.jpg" alt="img" style="zoom:50%;" />
<p>因为有一个表可以查询，就会遇到两种情况，一种是命中(Page Hit)，另一种则是未命中(Page Fault)。</p>
<p>命中的时候，即访问到页表中蓝色条目的地址时，因为在 DRAM 中有对应的数据，可以直接访问。</p>
<p>不命中的时候，即访问到 page table 中灰色条目的时候，因为在 DRAM 中并没有对应的数据，所以需要执行一系列操作（从磁盘复制到 DRAM 中），具体为：</p>
<ul>
<li>触发 Page fault，也就是一个异常</li>
<li>Page fault handler 会选择 DRAM 中需要被置换的 page，并把数据从磁盘复制到 DRAM 中</li>
<li>重新执行访问指令，这时候就会是 page hit</li>
</ul>
<p>复制过程中的等待时间称为 demand paging。</p>
<p>仔细留意上面的页表，会发现有一个条目是 null，也就是没有分配。具体的分配过程（比方说声明了一个大数组），就是让该条目指向虚拟内存（在磁盘上）的某个页，但并不复制到 DRAM，只有当出现 page fault 的时候才需要拷贝数据。</p>
<p>看起来『多此一举』，但是由于局部性原理，虚拟内存其实是非常高效的机制，这一部分最后提到了工作集(working set)[1]的概念，比较简单，这里不再赘述。</p>
<h4 id="作为内存管理工具">作为内存管理工具</h4>
<p>前面提到，每个进程都有自己的虚拟地址空间，这样一来，对于进程来说，它们看到的就是简单的线性空间（但实际上在物理内存中可能是间隔、支离破碎的），具体的映射过程可以用下图表示：</p>
<p><img src="https://wdxtub.com/images/csapp/14615040688550.jpg" alt="img"></p>
<p>在内存分配中没有太多限制，每个虚拟页都可以被映射到任何的物理页上。这样也带来一个好处，如果两个进程间有共享的数据，那么直接指向同一个物理页即可（也就是上图 PP 6 的状况，只读数据）</p>
<p>虚拟内存带来的另一个好处就是可以简化链接和载入的结构（因为有了统一的抽象，不需要纠结细节）</p>
<h4 id="作为内存保护工具">作为内存保护工具</h4>
<p>页表中的每个条目的高位部分是表示权限的位，MMU 可以通过检查这些位来进行权限控制（读、写、执行），如下图所示：</p>
<p><img src="https://wdxtub.com/images/csapp/14615862225552.jpg" alt="img"></p>
<h3 id="地址翻译">地址翻译</h3>
<p>开始之前先来了解以下参数：</p>
<p>N=2n,M=2m,P=2pN=2n,M=2m,P=2p</p>
<p>其中 <code>N</code> 表示虚拟地址空间中的地址数量，<code>M</code> 表示物理地址空间中的地址数量，<code>P</code> 是每一页包含的字节数(page size)。</p>
<p>虚拟地址(VA, Virtual Address)中的元素：</p>
<ul>
<li><code>TLBI</code>: TLB 的索引值</li>
<li><code>TLBT</code>: TLB 的标签(tag)</li>
<li><code>VPO</code>: 虚拟页偏移量</li>
<li><code>VPN</code>: 虚拟页编号</li>
</ul>
<p>物理地址(PA, physical address)中的元素：</p>
<ul>
<li><code>PPO</code>: 物理页偏移量（与 <code>VPO</code> 的值相同）</li>
<li><code>PPN</code>: 物理页编号</li>
</ul>
<p>然后我们通过一个具体的例子来说明如何进行地址翻译</p>
<p><img src="https://wdxtub.com/images/csapp/14615900211847.jpg" alt="img"></p>
<p>具体的访问过程为：</p>
<ul>
<li>通过虚拟地址找到页表(page table)中对应的条目</li>
<li>检查有效位(valid bit)，是否需要触发页错误(page fault)</li>
<li>然后根据页表中的物理页编号(physical page number)找到内存中的对应地址</li>
<li>最后把虚拟页偏移(virtual page offset)和前面的实际地址拼起来，就是最终的物理地址了</li>
</ul>
<p>这里又分两种情况：Page Hit 和 Page Fault，我们先来看看 Page Hit 的情况</p>
<p><img src="https://wdxtub.com/images/csapp/14619333202471.jpg" alt="img"></p>
<p>主要有 5 步，CPU 首先把虚拟地址发送给 MMU，MMU 检查缓存，并把从页表中得到对应的物理地址，接着 MMU 把物理地址发送给缓存/内存，最后从缓存/内存中得到数据。</p>
<p>而 Page Fault 的时候就复杂一些，第一次触发页错误会把页面载入内存/缓存，然后再以 Page Hit 的机制得到数据：</p>
<p><img src="https://wdxtub.com/images/csapp/14619339362618.jpg" alt="img"></p>
<p>这里有 7 步，前面和 Page Hit 是一致的，先把虚拟地址发给 MMU 进行检查，然后发现没有对应的页，于是触发异常，异常处理器会负责从磁盘中找到对应页面并与缓存/内存中的页进行置换，置换完成后再访问同一地址，就可以按照 Page Hit 的方式来访问了。</p>
<p>虽然缓存已经很快了，但是能不能更快呢，为什么不能直接在 MMU 进行一部分的工作呢？于是就有了另外一个设计：Translation Lookaside Buffer(TLB)。TLB 实际上可以认为是页表在处理芯片上的缓存，整体的机制和前面提到的缓存很像，我们通过下面的图进行讲解：</p>
<p><img src="https://wdxtub.com/images/csapp/14619349692957.jpg" alt="img"></p>
<p>这里 VPN + VPO 就是虚拟地址，同样分成三部分，分别用于匹配标签、确定集合，如果 TLB 中有对应的记录，那么直接返回对应页表项(PTE)即可，如果没有的话，就要从缓存/内存中获取，并更新 TLB 的对应集合。</p>
<h4 id="多层页表-multi-level-page-table">多层页表 Multi-Level Page Table</h4>
<p>虽然页表是一个表，但因为往往虚拟地址的位数比物理内存的位数要大得多，所以保存页表项(PTE) 所需要的空间也是一个问题。举个例子：</p>
<p>假设每个页的大小是 4KB（2 的 12 次方），每个地址有 48 位，一条 PTE 记录有 8 个字节，那么要全部保存下来，需要的大小是：</p>
<p>248×2−12×23=239bytes248×2−12×23=239bytes</p>
<p>整整 512 GB！所以我们采用多层页表，第一层的页表中的条目指向第二层的页表，一个一个索引下去，最终寻找具体的物理地址，整个翻译过程如下：</p>
<p><img src="https://wdxtub.com/images/csapp/14619365087673.jpg" alt="img"></p>
<h4 id="地址翻译实例">地址翻译实例</h4>
<p>来看一个简单的例子，我们的内存系统设定如下：</p>
<ul>
<li>14 位的虚拟地址</li>
<li>12 位的物理地址</li>
<li>页大小为 64 字节</li>
</ul>
<p>TLB 的配置为：</p>
<ul>
<li>能够存储 16 条记录</li>
<li>每个集合有 4 条记录</li>
</ul>
<p>系统本身缓存（对应于物理地址）：</p>
<ul>
<li>16 行，每个块 4 个字节</li>
<li>直接映射（即 16 个集合）</li>
</ul>
<p><img src="https://wdxtub.com/images/csapp/14619386956596.jpg" alt="img"></p>
<p>TLB 中的数据为</p>
<p><img src="https://wdxtub.com/images/csapp/14619392574046.jpg" alt="img"></p>
<p>页表中的数据为（一共有 256 条记录，这里列出前 16 个）</p>
<img src="https://wdxtub.com/images/csapp/14619394874702.jpg" alt="img" style="zoom:50%;" />
<p>缓存中的数据为</p>
<p><img src="https://wdxtub.com/images/csapp/14619399183944.jpg" alt="img"></p>
<p>一定要注意好不同部分的所代表的位置，这里我也会尽量写得清楚一些，来看第一个例子：</p>
<blockquote>
<p>虚拟地址为 <code>0x03D4</code></p>
</blockquote>
<p>具体的转换过程如下图所示：</p>
<img src="https://wdxtub.com/images/csapp/14619404450222.jpg" alt="img" style="zoom:50%;" />
<p>具体来梳理一次：</p>
<p>先看 TLB 中有没有对应的条目，所以先看虚拟地址的第 6-13 位，在前面的 TLB 表中，根据 TLBI 为 3 这个信息，去看这个 set 中有没有 tag 为 3 的项目，发现有，并且对应的 PPN 是 0x0D，所以对应到物理地址，就是 PPN 加上虚拟地址的 0-5 位，而具体的物理地址又可以在缓存中找到（利用 cache memory 的机制），就可以获取到对应的数据了。</p>
<p>下面的例子同样可以按照这个方法来进行分析</p>
<blockquote>
<p>虚拟地址为 <code>0x0020</code></p>
</blockquote>
<img src="https://wdxtub.com/images/csapp/14619405964352.jpg" alt="img" style="zoom:50%;" />
<h3 id="动态内存分配">动态内存分配</h3>
<p>前面了解了虚拟内存的相关知识，这一节我们来看看动态内存分配的基本概念，相信这之后就知道诸如 <code>malloc</code> 和 <code>new</code> 这类方法是怎么做的了。</p>
<p>程序员通过动态内存分配（例如 <code>malloc</code>）来让程序在运行时得到虚拟内存。动态内存分配器会管理一个虚拟内存区域，称为堆(heap)。</p>
<p>分配器以块为单位来维护堆，可以进行分配或释放。有两种类型的分配器：</p>
<ul>
<li>显式分配器：应用分配并且回收空间（C 语言中的 <code>malloc</code> 和 <code>free</code>）</li>
<li>隐式分配器：应用只负责分配，但是不负责回收（Java 中的垃圾收集）</li>
</ul>
<p>先来看看一个简单的使用 <code>malloc</code> 和 <code>free</code> 的例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="cm">/* Allocate a block of n ints */</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;malloc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="cm">/* Initialize allocated block */</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Return allocated block to the heap */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了讲述方便，我们做如下假设：</p>
<ul>
<li>内存地址按照字来编码</li>
<li>每个字的大小和整型一致</li>
</ul>
<p>例如：</p>
<p><img src="https://wdxtub.com/images/csapp/14619422087381.jpg" alt="img"></p>
<p>程序可以用任意的顺序发送 <code>malloc</code> 和 <code>free</code> 请求，<code>free</code> 请求必须作用与已被分配的 block。</p>
<p>分配器有如下的限制：</p>
<ul>
<li>不能控制已分配块的数量和大小</li>
<li>必须立即响应 <code>malloc</code> 请求（不能缓存或者给请求重新排序）</li>
<li>必须在未分配的内存中分配</li>
<li>不同的块需要对齐（32 位中 8 byte，64 位中 16 byte）</li>
<li>只能操作和修改未分配的内存</li>
<li>不能移动已分配的块</li>
</ul>
<h4 id="性能指标">性能指标</h4>
<p>现在我们可以来看看如何去评测具体的分配算法了。假设给定一个 <code>malloc</code> 和 <code>free</code> 的请求的序列：</p>
<p>R0,R1,&hellip;,Rk,&hellip;,Rn−1R0,R1,&hellip;,Rk,&hellip;,Rn−1</p>
<p>目标是尽可能提高吞吐量以及内存利用率（注意，这两个目标常常是冲突的）</p>
<p>吞吐量是在单位时间内完成的请求数量。假设在 10 秒中之内进行了 5000 次 <code>malloc</code> 和 5000 次 <code>free</code> 调用，那么吞吐量是 1000 operations/second</p>
<p>另外一个目标是 Peak Memory Utilization，就是最大的内存利用率。</p>
<p>影响内存利用率的主要因素就是『内存碎片』，分为内部碎片和外部碎片两种。</p>
<p><strong>内部碎片</strong></p>
<p>内部碎片指的是对于给定的块，如果需要存储的数据(payload)小于块大小，就会因为对齐和维护堆所需的数据结构的缘故而出现无法利用的空间，例如：</p>
<p><img src="https://wdxtub.com/images/csapp/14619426495995.jpg" alt="img"></p>
<p>内部碎片只依赖于上一个请求的具体模式，所以比较容易测量。</p>
<p><strong>外部碎片</strong></p>
<p>指的是内存中没有足够的连续空间，如下图所示，内存中有足够的空间，但是空间不连续，所以成为了碎片：</p>
<p><img src="https://wdxtub.com/images/csapp/14619429933039.jpg" alt="img"></p>
<h4 id="实现细节">实现细节</h4>
<p>我们已经知道了原理，现在就来看看怎么样能够实现一个高效的内存分配算法吧！在具体实现之前，需要考虑以下问题：</p>
<ul>
<li>给定一个指针，我们如何知道需要释放多少内存？</li>
<li>如何记录未分配的块？</li>
<li>实际需要的空间比未分配的空间要小的时候，剩下的空间怎么办？</li>
<li>如果有多个区域满足条件，如何选择？</li>
<li>释放空间之后如何进行记录？</li>
</ul>
<p>具体这部分书中提到了四种方法：</p>
<ol>
<li>隐式空闲列表 Implicit List</li>
<li>显式空闲列表 Explicit List</li>
<li>分离的空闲列表 Segregated Free List</li>
<li>按照大小对块进行排序 Blocks Sorted by Size</li>
</ol>
<p>因为涉及的细节比较多，建议是详读书本的对应章节（第二版和第三版均为第九章第九节），这里不再赘述（如果需要的话之后我在另起一篇做详细介绍）</p>
<p>这里提一点，就是如何确定哪部分空间合适，有三种方法：</p>
<ol>
<li>First Fit: 每次都从头进行搜索，找到第一个合适的块，线性查找</li>
<li>Next Fit: 每次从上次搜索结束的位置继续搜索，速度较快，但可能会有更多碎片</li>
<li>Best Fit: 每次遍历列表，找到最合适的块，碎片较少，但是速度最慢</li>
</ol>
<p>更详细可以参考这两篇文章：<a href="http://wdxtub.com/vault/csapp-18.html">Dynamic Memory Allocation - Basic Concept</a> 和 <a href="http://wdxtub.com/vault/csapp-19.html">Dynamic Memory Allocation - Advanced Concept</a></p>
<h3 id="垃圾回收">垃圾回收</h3>
<p>所谓垃圾回收，就是我们不再需要显式释放所申请内存空间了，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void foo() {
</span></span><span class="line"><span class="cl">    int *p = malloc(128);
</span></span><span class="line"><span class="cl">    return; /* p block is now garbage*/
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种机制在许多动态语言中都有实现：Python, Ruby, Java, Perl, ML, Lisp, Mathematica。C 和 C++ 中也有类似的变种，但是需要注意的是，是不可能回收所有的垃圾的。</p>
<p>我们如何知道什么东西才是『垃圾』呢？简单！只要没有任何指针指向的地方，不管有没有用，因为都不可能被使用，当然可以直接清理掉啦。不过这其实是需要一些前提条件的：</p>
<ul>
<li>我们可以知道哪里是指针，哪里不是指针</li>
<li>每个指针都指向 block 的开头</li>
<li>指针不能被隐藏(by coercing them to an <code>int</code>, and then back again)</li>
</ul>
<p>相关的算法如下：</p>
<ul>
<li>Mark-and-sweep collection (McCarthy, 1960)</li>
<li>Reference counting (Collins, 1960)</li>
<li>Copying collection (Minsky, 1963)</li>
<li>Generational Collectors(Lieberman and Hewitt, 1983)</li>
</ul>
<p>大部分比较常用的算法居然都有五十多年历史了，神奇。更多相关细节在维基百科[2]中都有详细介绍（中文版本质量较差，这里给出英文版）。</p>
<h3 id="segregated-free-list">Segregated Free List</h3>
<p>Due to lack of time, pleace check 9.9 in the book for more infomation.</p>
<h3 id="内存陷阱">内存陷阱</h3>
<p>关于内存的使用需要注意避免以下问题：</p>
<ul>
<li>解引用错误指针</li>
<li>读取未初始化的内存</li>
<li>覆盖内存</li>
<li>引用不存在的变量</li>
<li>多次释放同一个块</li>
<li>引用已释放的块</li>
<li>释放块失败</li>
</ul>
<h4 id="dereferencing-bad-pointers">Dereferencing Bad Pointers</h4>
<p>这是非常常见的例子，没有引用对应的地址，少了 <code>&amp;</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int val;
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">scanf(&#34;%d&#34;, val);
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="reading-uninitialized-memory">Reading Uninitialized Memory</h4>
<p>不能假设堆中的数据会自动初始化为 0，下面的代码就会出现奇怪的问题</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/* return y = Ax */
</span></span><span class="line"><span class="cl">int *matvec(int **A, int *x) {
</span></span><span class="line"><span class="cl">    int *y = malloc(N * sizeof(int));
</span></span><span class="line"><span class="cl">    int i, j;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    for (i = 0; i &lt; N; i++)
</span></span><span class="line"><span class="cl">        for (j = 0; j &lt; N; j++)
</span></span><span class="line"><span class="cl">            y[i] += A[i][j] * x[j];
</span></span><span class="line"><span class="cl">    return y;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="overwriting-memory">Overwriting Memory</h4>
<p>这里有挺多问题，第一种是分配了错误的大小，下面的例子中，一开始不能用 <code>sizeof(int)</code>，因为指针的长度不一定和 int 一样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int **p;
</span></span><span class="line"><span class="cl">p = malloc(N * sizeof(int));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">for (i = 0; i &lt; N; i++) 
</span></span><span class="line"><span class="cl">    p[i] = malloc(M * sizeof(int));
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二个问题是超出了分配的空间，下面代码的 for 循环中，因为使用了 <code>&lt;=</code>，会写入到其他位置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int **p;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">p = malloc(N * sizeof (int *));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">for (i = 0; i &lt;= N; i++)
</span></span><span class="line"><span class="cl">    p[i] = malloc(M * sizeof(int));
</span></span></code></pre></td></tr></table>
</div>
</div><p>第三种是因为没有检查字符串的长度，超出部分就写到其他地方去了（经典的缓冲区溢出攻击也是利用相同的机制）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char s[8];
</span></span><span class="line"><span class="cl">int i;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">gets(s); /* reads &#34;123456789&#34; from stdin */
</span></span></code></pre></td></tr></table>
</div>
</div><p>第四种是没有正确理解指针的大小以及对应的操作，应该使用 <code>sizeof(int *)</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int *search(int *p, int val) {
</span></span><span class="line"><span class="cl">    while (*p &amp;&amp; *p != null)
</span></span><span class="line"><span class="cl">        p += sizeof(int);
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    return p;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>第五种是引用了指针，而不是其指向的对象，下面的例子中，<code>*size--</code> 一句因为 <code>--</code> 的优先级比较高，所以实际上是对指针进行了操作，正确的应该是 <code>(*size)--</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int *BinheapDelete(int **binheap, int *size) {
</span></span><span class="line"><span class="cl">    int *packet;
</span></span><span class="line"><span class="cl">    packet = binheap[0];
</span></span><span class="line"><span class="cl">    binheap[0] = binheap[*size - 1];
</span></span><span class="line"><span class="cl">    *size--;
</span></span><span class="line"><span class="cl">    Heapify(binheap, *size, 0);
</span></span><span class="line"><span class="cl">    return (packet);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="referencing-nonexistent-variables">Referencing Nonexistent Variables</h4>
<p>下面的情况中，没有注意到局部变量会在函数返回的时候失效（所以对应的指针也会无效），这是传引用和返回引用需要注意的，传值的话则不用担心</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int *foo() {
</span></span><span class="line"><span class="cl">    int val;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    return &amp;val;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="freeing-blocks-multiple-times">Freeing Blocks Multiple Times</h4>
<p>这个不用多说，不能重复搞两次</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">x = malloc(N * sizeof(int));
</span></span><span class="line"><span class="cl">//  &lt;manipulate x&gt;
</span></span><span class="line"><span class="cl">free(x);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">y = malloc(M * sizeof(int));
</span></span><span class="line"><span class="cl">//  &lt;manipulate y&gt;
</span></span><span class="line"><span class="cl">free(x);
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="referencing-freed-blocks">Referencing Freed Blocks</h4>
<p>同样是很明显的错误，不要犯</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">x = malloc(N * sizeof(int));
</span></span><span class="line"><span class="cl">//  &lt;manipulate x&gt;
</span></span><span class="line"><span class="cl">free(x);
</span></span><span class="line"><span class="cl">//  ....
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">y = malloc(M * sizeof(int));
</span></span><span class="line"><span class="cl">for (i = 0; i &lt; M; i++)
</span></span><span class="line"><span class="cl">    y[i] = x[i]++;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="memory-leaks">Memory Leaks</h4>
<p>用完没有释放，就是内存泄露啦</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">foo() {
</span></span><span class="line"><span class="cl">    int *x = malloc(N * sizeof(int));
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">    return ;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>或者只释放了数据结构的一部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">struct list {
</span></span><span class="line"><span class="cl">    int val;
</span></span><span class="line"><span class="cl">    struct list *next;
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">foo() {
</span></span><span class="line"><span class="cl">    struct list *head = malloc(sizeof(struct list));
</span></span><span class="line"><span class="cl">    head-&gt;val = 0;
</span></span><span class="line"><span class="cl">    head-&gt;next = NULL;
</span></span><span class="line"><span class="cl">    //...
</span></span><span class="line"><span class="cl">    free(head);
</span></span><span class="line"><span class="cl">    return;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div></article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://Timlin15.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://Timlin15.github.io/css/toc.css' />

  
</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://Timlin15.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Lin</li>
      
      <li class="mr-3 mr-lg-0">GitHub and the Invertocat logo are trademarks of <a href="https://github.com/">GitHub, Inc.</a></li>
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>

</body>

<script type="application/javascript" src="https://Timlin15.github.io/js/github-style.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
  integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
  integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
  integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





<script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script type="application/javascript" src='https://Timlin15.github.io/js/search.js'></script>



</html>